#!/usr/bin/env python3
"""
Vulnerability Report Management System
Handles submission, validation, and lifecycle management of vulnerability reports
"""

import uuid
from typing import List, Dict, Any, Optional, Set
from dataclasses import dataclass, field
from datetime import datetime, timedelta
from enum import Enum
import json
import hashlib
from decimal import Decimal

class ReportStatus(Enum):
    SUBMITTED = "submitted"
    TRIAGED = "triaged"
    VALID = "valid"
    INVALID = "invalid"
    DUPLICATE = "duplicate"
    FIXED = "fixed"
    REWARDED = "rewarded"
    CLOSED = "closed"

class VulnerabilityType(Enum):
    SQL_INJECTION = "sql_injection"
    XSS = "cross_site_scripting"
    CSRF = "cross_site_request_forgery"
    XXE = "xml_external_entity"
    SSRF = "server_side_request_forgery"
    COMMAND_INJECTION = "command_injection"
    PATH_TRAVERSAL = "path_traversal"
    AUTH_BYPASS = "authentication_bypass"
    PRIVILEGE_ESCALATION = "privilege_escalation"
    INFORMATION_DISCLOSURE = "information_disclosure"
    BUSINESS_LOGIC = "business_logic_flaw"
    CRYPTOGRAPHIC = "cryptographic_issue"
    CONFIGURATION = "security_misconfiguration"
    DENIAL_OF_SERVICE = "denial_of_service"
    OTHER = "other"

class Severity(Enum):
    CRITICAL = "critical"
    HIGH = "high"
    MEDIUM = "medium"
    LOW = "low"
    INFO = "info"

class ValidationResult(Enum):
    PENDING = "pending"
    CONFIRMED = "confirmed"
    REJECTED = "rejected"
    NEEDS_MORE_INFO = "needs_more_info"

@dataclass
class AttachmentFile:
    """Represents an attached file to a vulnerability report"""
    file_id: str
    filename: str
    file_size: int
    content_type: str
    upload_date: datetime
    description: Optional[str] = None
    is_proof_of_concept: bool = False

@dataclass
class ReportComment:
    """Comments on vulnerability reports"""
    comment_id: str
    author_id: str
    author_type: str  # "researcher", "triager", "admin"
    content: str
    timestamp: datetime
    is_internal: bool = False  # Internal comments not visible to researcher
    attachments: List[str] = field(default_factory=list)  # File IDs

@dataclass
class ValidationStep:
    """Individual validation step in the review process"""
    step_id: str
    validator_id: str
    step_name: str
    result: ValidationResult
    notes: str
    timestamp: datetime
    time_spent: Optional[float] = None  # Time spent in hours

@dataclass
class VulnerabilityReport:
    """Represents a vulnerability report submission"""
    report_id: str
    program_id: str
    researcher_id: str
    
    # Report content
    title: str
    description: str
    vulnerability_type: VulnerabilityType
    severity: Severity
    affected_url: Optional[str] = None
    affected_parameter: Optional[str] = None
    proof_of_concept: Optional[str] = None
    impact_description: str = ""
    remediation_suggestion: Optional[str] = None
    
    # Status and workflow
    status: ReportStatus = ReportStatus.SUBMITTED
    validation_result: ValidationResult = ValidationResult.PENDING
    assigned_triager: Optional[str] = None
    
    # Timestamps
    submitted_date: datetime = field(default_factory=datetime.now)
    last_updated: datetime = field(default_factory=datetime.now)
    triaged_date: Optional[datetime] = None
    resolved_date: Optional[datetime] = None
    
    # Attachments and comments
    attachments: List[AttachmentFile] = field(default_factory=list)
    comments: List[ReportComment] = field(default_factory=list)
    validation_steps: List[ValidationStep] = field(default_factory=list)
    
    # Reward information
    reward_amount: Optional[Decimal] = None
    reward_currency: str = "USD"
    reward_paid: bool = False
    reward_date: Optional[datetime] = None
    
    # Technical details
    cve_id: Optional[str] = None
    cvss_score: Optional[float] = None
    exploit_complexity: Optional[str] = None
    affected_versions: List[str] = field(default_factory=list)
    
    # Duplicate detection
    duplicate_of: Optional[str] = None
    related_reports: Set[str] = field(default_factory=set)
    
    # Internal tracking
    internal_tags: Set[str] = field(default_factory=set)
    priority_score: int = 0  # Internal priority scoring
    auto_scan_generated: bool = False
    scan_correlation_id: Optional[str] = None

class ReportManager:
    """Manages vulnerability reports and their lifecycle"""
    
    def __init__(self):
        self.reports: Dict[str, VulnerabilityReport] = {}
        self.researcher_reports: Dict[str, List[str]] = {}  # researcher_id -> report_ids
        self.program_reports: Dict[str, List[str]] = {}    # program_id -> report_ids
        self.triager_workload: Dict[str, List[str]] = {}   # triager_id -> report_ids
        
        # Duplicate detection cache
        self.report_fingerprints: Dict[str, str] = {}  # fingerprint -> report_id
        
        # Validation workflow templates
        self.validation_workflows = {
            "standard": [
                "initial_triage",
                "technical_validation",
                "impact_assessment",
                "duplicate_check",
                "final_review"
            ],
            "critical": [
                "urgent_triage",
                "deep_technical_analysis",
                "business_impact_assessment",
                "duplicate_check",
                "security_team_review",
                "final_approval"
            ],
            "automated_scan": [
                "auto_validation",
                "false_positive_check",
                "manual_verification"
            ]
        }

    def submit_report(
        self,
        program_id: str,
        researcher_id: str,
        title: str,
        description: str,
        vulnerability_type: VulnerabilityType,
        severity: Severity,
        **kwargs
    ) -> VulnerabilityReport:
        """Submit a new vulnerability report"""
        report_id = str(uuid.uuid4())
        
        report = VulnerabilityReport(
            report_id=report_id,
            program_id=program_id,
            researcher_id=researcher_id,
            title=title,
            description=description,
            vulnerability_type=vulnerability_type,
            severity=severity,
            **kwargs
        )
        
        # Generate fingerprint for duplicate detection
        fingerprint = self._generate_report_fingerprint(report)
        
        # Check for potential duplicates
        if fingerprint in self.report_fingerprints:
            existing_report_id = self.report_fingerprints[fingerprint]
            report.related_reports.add(existing_report_id)
            
            # Add reference in existing report
            existing_report = self.reports.get(existing_report_id)
            if existing_report:
                existing_report.related_reports.add(report_id)
        
        self.report_fingerprints[fingerprint] = report_id
        self.reports[report_id] = report
        
        # Track by researcher and program
        if researcher_id not in self.researcher_reports:
            self.researcher_reports[researcher_id] = []
        self.researcher_reports[researcher_id].append(report_id)
        
        if program_id not in self.program_reports:
            self.program_reports[program_id] = []
        self.program_reports[program_id].append(report_id)
        
        # Calculate initial priority score
        report.priority_score = self._calculate_priority_score(report)
        
        return report

    def get_report(self, report_id: str) -> Optional[VulnerabilityReport]:
        """Get a report by ID"""
        return self.reports.get(report_id)

    def list_reports(
        self,
        program_id: Optional[str] = None,
        researcher_id: Optional[str] = None,
        status: Optional[ReportStatus] = None,
        severity: Optional[Severity] = None,
        limit: int = 100
    ) -> List[VulnerabilityReport]:
        """List reports with optional filters"""
        reports = list(self.reports.values())
        
        if program_id:
            report_ids = self.program_reports.get(program_id, [])
            reports = [r for r in reports if r.report_id in report_ids]
        
        if researcher_id:
            report_ids = self.researcher_reports.get(researcher_id, [])
            reports = [r for r in reports if r.report_id in report_ids]
        
        if status:
            reports = [r for r in reports if r.status == status]
        
        if severity:
            reports = [r for r in reports if r.severity == severity]
        
        # Sort by priority score and submission date
        reports.sort(key=lambda r: (-r.priority_score, -r.submitted_date.timestamp()))
        
        return reports[:limit]

    def assign_triager(self, report_id: str, triager_id: str) -> bool:
        """Assign a report to a triager"""
        report = self.reports.get(report_id)
        if not report:
            return False
        
        # Remove from previous triager if assigned
        if report.assigned_triager:
            old_triager_reports = self.triager_workload.get(report.assigned_triager, [])
            if report_id in old_triager_reports:
                old_triager_reports.remove(report_id)
        
        # Assign to new triager
        report.assigned_triager = triager_id
        report.last_updated = datetime.now()
        
        if triager_id not in self.triager_workload:
            self.triager_workload[triager_id] = []
        self.triager_workload[triager_id].append(report_id)
        
        return True

    def update_status(self, report_id: str, new_status: ReportStatus, notes: Optional[str] = None) -> bool:
        """Update report status"""
        report = self.reports.get(report_id)
        if not report:
            return False
        
        old_status = report.status
        report.status = new_status
        report.last_updated = datetime.now()
        
        # Set specific timestamps based on status
        if new_status == ReportStatus.TRIAGED and not report.triaged_date:
            report.triaged_date = datetime.now()
        elif new_status in [ReportStatus.FIXED, ReportStatus.CLOSED] and not report.resolved_date:
            report.resolved_date = datetime.now()
        
        # Add status change comment
        if notes:
            self.add_comment(
                report_id,
                "system",
                "system",
                f"Status changed from {old_status.value} to {new_status.value}: {notes}",
                is_internal=True
            )
        
        return True

    def validate_report(
        self,
        report_id: str,
        validator_id: str,
        result: ValidationResult,
        notes: str,
        step_name: str = "manual_validation"
    ) -> bool:
        """Add validation step to report"""
        report = self.reports.get(report_id)
        if not report:
            return False
        
        validation_step = ValidationStep(
            step_id=str(uuid.uuid4()),
            validator_id=validator_id,
            step_name=step_name,
            result=result,
            notes=notes,
            timestamp=datetime.now()
        )
        
        report.validation_steps.append(validation_step)
        report.validation_result = result
        report.last_updated = datetime.now()
        
        # Update status based on validation result
        if result == ValidationResult.CONFIRMED:
            report.status = ReportStatus.VALID
        elif result == ValidationResult.REJECTED:
            report.status = ReportStatus.INVALID
        
        return True

    def mark_duplicate(self, report_id: str, duplicate_of: str, validator_id: str) -> bool:
        """Mark a report as duplicate of another"""
        report = self.reports.get(report_id)
        original_report = self.reports.get(duplicate_of)
        
        if not report or not original_report:
            return False
        
        report.status = ReportStatus.DUPLICATE
        report.duplicate_of = duplicate_of
        report.validation_result = ValidationResult.REJECTED
        report.last_updated = datetime.now()
        
        # Add to related reports
        report.related_reports.add(duplicate_of)
        original_report.related_reports.add(report_id)
        
        # Add validation step
        self.validate_report(
            report_id,
            validator_id,
            ValidationResult.REJECTED,
            f"Marked as duplicate of report {duplicate_of}",
            "duplicate_check"
        )
        
        return True

    def add_comment(
        self,
        report_id: str,
        author_id: str,
        author_type: str,
        content: str,
        is_internal: bool = False,
        attachments: List[str] = None
    ) -> Optional[str]:
        """Add a comment to a report"""
        report = self.reports.get(report_id)
        if not report:
            return None
        
        comment_id = str(uuid.uuid4())
        comment = ReportComment(
            comment_id=comment_id,
            author_id=author_id,
            author_type=author_type,
            content=content,
            timestamp=datetime.now(),
            is_internal=is_internal,
            attachments=attachments or []
        )
        
        report.comments.append(comment)
        report.last_updated = datetime.now()
        
        return comment_id

    def add_attachment(
        self,
        report_id: str,
        filename: str,
        file_size: int,
        content_type: str,
        description: Optional[str] = None,
        is_proof_of_concept: bool = False
    ) -> Optional[str]:
        """Add an attachment to a report"""
        report = self.reports.get(report_id)
        if not report:
            return None
        
        file_id = str(uuid.uuid4())
        attachment = AttachmentFile(
            file_id=file_id,
            filename=filename,
            file_size=file_size,
            content_type=content_type,
            upload_date=datetime.now(),
            description=description,
            is_proof_of_concept=is_proof_of_concept
        )
        
        report.attachments.append(attachment)
        report.last_updated = datetime.now()
        
        return file_id

    def set_reward(self, report_id: str, amount: Decimal, currency: str = "USD") -> bool:
        """Set reward amount for a report"""
        report = self.reports.get(report_id)
        if not report:
            return False
        
        report.reward_amount = amount
        report.reward_currency = currency
        report.last_updated = datetime.now()
        
        return True

    def pay_reward(self, report_id: str, payer_id: str) -> bool:
        """Mark reward as paid"""
        report = self.reports.get(report_id)
        if not report or not report.reward_amount:
            return False
        
        report.reward_paid = True
        report.reward_date = datetime.now()
        report.status = ReportStatus.REWARDED
        report.last_updated = datetime.now()
        
        # Add payment comment
        self.add_comment(
            report_id,
            payer_id,
            "admin",
            f"Reward of {report.reward_amount} {report.reward_currency} has been paid",
            is_internal=True
        )
        
        return True

    def get_researcher_stats(self, researcher_id: str) -> Dict[str, Any]:
        """Get statistics for a researcher"""
        report_ids = self.researcher_reports.get(researcher_id, [])
        reports = [self.reports[rid] for rid in report_ids if rid in self.reports]
        
        if not reports:
            return {}
        
        stats = {
            'total_reports': len(reports),
            'valid_reports': len([r for r in reports if r.status == ReportStatus.VALID]),
            'invalid_reports': len([r for r in reports if r.status == ReportStatus.INVALID]),
            'duplicate_reports': len([r for r in reports if r.status == ReportStatus.DUPLICATE]),
            'total_rewards': sum(r.reward_amount or Decimal('0') for r in reports if r.reward_paid),
            'average_reward': Decimal('0'),
            'severity_breakdown': {},
            'vulnerability_types': {},
            'validity_rate': 0,
            'first_report_date': None,
            'last_report_date': None,
            'average_response_time': 0
        }
        
        # Calculate validity rate
        if stats['total_reports'] > 0:
            stats['validity_rate'] = stats['valid_reports'] / stats['total_reports']
        
        # Calculate average reward
        paid_reports = [r for r in reports if r.reward_paid and r.reward_amount]
        if paid_reports:
            stats['average_reward'] = sum(r.reward_amount for r in paid_reports) / len(paid_reports)
        
        # Severity breakdown
        for severity in Severity:
            count = len([r for r in reports if r.severity == severity])
            if count > 0:
                stats['severity_breakdown'][severity.value] = count
        
        # Vulnerability types
        for vuln_type in VulnerabilityType:
            count = len([r for r in reports if r.vulnerability_type == vuln_type])
            if count > 0:
                stats['vulnerability_types'][vuln_type.value] = count
        
        # Date range
        if reports:
            report_dates = [r.submitted_date for r in reports]
            stats['first_report_date'] = min(report_dates).isoformat()
            stats['last_report_date'] = max(report_dates).isoformat()
        
        # Average response time (submission to triage)
        triaged_reports = [r for r in reports if r.triaged_date]
        if triaged_reports:
            response_times = [
                (r.triaged_date - r.submitted_date).total_seconds() / 3600
                for r in triaged_reports
            ]
            stats['average_response_time'] = sum(response_times) / len(response_times)
        
        return stats

    def get_program_stats(self, program_id: str) -> Dict[str, Any]:
        """Get statistics for a program"""
        report_ids = self.program_reports.get(program_id, [])
        reports = [self.reports[rid] for rid in report_ids if rid in self.reports]
        
        if not reports:
            return {}
        
        stats = {
            'total_reports': len(reports),
            'valid_reports': len([r for r in reports if r.status == ReportStatus.VALID]),
            'invalid_reports': len([r for r in reports if r.status == ReportStatus.INVALID]),
            'duplicate_reports': len([r for r in reports if r.status == ReportStatus.DUPLICATE]),
            'pending_reports': len([r for r in reports if r.status == ReportStatus.SUBMITTED]),
            'total_rewards_paid': sum(r.reward_amount or Decimal('0') for r in reports if r.reward_paid),
            'unique_researchers': len(set(r.researcher_id for r in reports)),
            'severity_breakdown': {},
            'monthly_submissions': {},
            'average_resolution_time': 0,
            'top_vulnerability_types': {}
        }
        
        # Severity breakdown
        for severity in Severity:
            count = len([r for r in reports if r.severity == severity])
            if count > 0:
                stats['severity_breakdown'][severity.value] = count
        
        # Monthly submissions (last 12 months)
        from collections import defaultdict
        monthly_counts = defaultdict(int)
        for report in reports:
            month_key = report.submitted_date.strftime('%Y-%m')
            monthly_counts[month_key] += 1
        stats['monthly_submissions'] = dict(monthly_counts)
        
        # Average resolution time
        resolved_reports = [r for r in reports if r.resolved_date]
        if resolved_reports:
            resolution_times = [
                (r.resolved_date - r.submitted_date).total_seconds() / 3600 / 24  # days
                for r in resolved_reports
            ]
            stats['average_resolution_time'] = sum(resolution_times) / len(resolution_times)
        
        # Top vulnerability types
        vuln_type_counts = defaultdict(int)
        for report in reports:
            vuln_type_counts[report.vulnerability_type.value] += 1
        
        stats['top_vulnerability_types'] = dict(
            sorted(vuln_type_counts.items(), key=lambda x: x[1], reverse=True)[:10]
        )
        
        return stats

    def _generate_report_fingerprint(self, report: VulnerabilityReport) -> str:
        """Generate fingerprint for duplicate detection"""
        # Combine key fields for similarity detection
        content = f"{report.title.lower()}{report.vulnerability_type.value}{report.affected_url or ''}"
        return hashlib.md5(content.encode()).hexdigest()

    def _calculate_priority_score(self, report: VulnerabilityReport) -> int:
        """Calculate priority score for report triage"""
        score = 0
        
        # Severity-based scoring
        severity_scores = {
            Severity.CRITICAL: 100,
            Severity.HIGH: 75,
            Severity.MEDIUM: 50,
            Severity.LOW: 25,
            Severity.INFO: 10
        }
        score += severity_scores.get(report.severity, 0)
        
        # Vulnerability type adjustments
        high_impact_types = {
            VulnerabilityType.SQL_INJECTION,
            VulnerabilityType.COMMAND_INJECTION,
            VulnerabilityType.AUTH_BYPASS,
            VulnerabilityType.PRIVILEGE_ESCALATION
        }
        if report.vulnerability_type in high_impact_types:
            score += 20
        
        # Proof of concept bonus
        if report.proof_of_concept:
            score += 10
        
        # Auto-scan penalty (lower priority for automated findings)
        if report.auto_scan_generated:
            score -= 20
        
        return max(score, 0)

    def search_reports(
        self,
        query: str,
        filters: Dict[str, Any] = None,
        limit: int = 50
    ) -> List[VulnerabilityReport]:
        """Search reports by content"""
        reports = list(self.reports.values())
        
        # Text search
        if query:
            query_lower = query.lower()
            reports = [
                r for r in reports
                if (query_lower in r.title.lower() or 
                    query_lower in r.description.lower() or
                    query_lower in (r.affected_url or '').lower())
            ]
        
        # Apply filters
        if filters:
            if 'severity' in filters:
                reports = [r for r in reports if r.severity.value == filters['severity']]
            
            if 'status' in filters:
                reports = [r for r in reports if r.status.value == filters['status']]
            
            if 'vulnerability_type' in filters:
                reports = [r for r in reports if r.vulnerability_type.value == filters['vulnerability_type']]
            
            if 'date_from' in filters:
                date_from = datetime.fromisoformat(filters['date_from'])
                reports = [r for r in reports if r.submitted_date >= date_from]
            
            if 'date_to' in filters:
                date_to = datetime.fromisoformat(filters['date_to'])
                reports = [r for r in reports if r.submitted_date <= date_to]
        
        # Sort by priority score
        reports.sort(key=lambda r: (-r.priority_score, -r.submitted_date.timestamp()))
        
        return reports[:limit]

# Example usage
def example_usage():
    """Example of how to use the ReportManager"""
    manager = ReportManager()
    
    # Submit a report
    report = manager.submit_report(
        program_id="prog_123",
        researcher_id="researcher_456",
        title="SQL Injection in Login Form",
        description="The login form is vulnerable to SQL injection attacks...",
        vulnerability_type=VulnerabilityType.SQL_INJECTION,
        severity=Severity.HIGH,
        affected_url="https://example.com/login",
        affected_parameter="username",
        proof_of_concept="' OR 1=1 --"
    )
    
    print(f"Report submitted: {report.report_id}")
    
    # Assign to triager
    manager.assign_triager(report.report_id, "triager_789")
    
    # Add comment
    manager.add_comment(
        report.report_id,
        "triager_789",
        "triager",
        "Confirmed the vulnerability. Reproducing the issue now."
    )
    
    # Validate report
    manager.validate_report(
        report.report_id,
        "triager_789",
        ValidationResult.CONFIRMED,
        "SQL injection confirmed with high impact"
    )
    
    # Set reward
    manager.set_reward(report.report_id, Decimal('2500.00'))
    
    # Get researcher stats
    stats = manager.get_researcher_stats("researcher_456")
    print(f"Researcher stats: {json.dumps(stats, indent=2, default=str)}")

if __name__ == "__main__":
    example_usage()