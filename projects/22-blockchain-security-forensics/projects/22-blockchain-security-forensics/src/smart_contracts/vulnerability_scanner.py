#!/usr/bin/env python3
"""
Smart Contract Vulnerability Scanner
Advanced security analysis for smart contracts and DeFi protocols
Author: Blockchain Security Team  
Version: 1.0.0
"""

import re
import json
import hashlib
import requests
from datetime import datetime
from typing import Dict, List, Optional, Tuple, Any, Set
from dataclasses import dataclass, asdict
from enum import Enum
import ast

class VulnerabilityType(Enum):
    """Types of smart contract vulnerabilities"""
    REENTRANCY = "reentrancy"
    INTEGER_OVERFLOW = "integer_overflow"
    ACCESS_CONTROL = "access_control"
    UNCHECKED_CALL = "unchecked_call"
    FRONT_RUNNING = "front_running"
    FLASH_LOAN_ATTACK = "flash_loan_attack"
    ORACLE_MANIPULATION = "oracle_manipulation"
    GOVERNANCE_ATTACK = "governance_attack"
    DENIAL_OF_SERVICE = "denial_of_service"
    TIMESTAMP_DEPENDENCE = "timestamp_dependence"
    TX_ORIGIN = "tx_origin"
    DELEGATECALL = "delegatecall"
    UNINITIALIZED_STORAGE = "uninitialized_storage"
    SHORT_ADDRESS = "short_address"

class SeverityLevel(Enum):
    """Vulnerability severity levels"""
    CRITICAL = "critical"
    HIGH = "high"
    MEDIUM = "medium"
    LOW = "low"
    INFORMATIONAL = "informational"

@dataclass
class Vulnerability:
    """Represents a detected vulnerability"""
    vuln_id: str
    vuln_type: VulnerabilityType
    severity: SeverityLevel
    title: str
    description: str
    location: Dict[str, Any]  # file, line, function
    code_snippet: str
    recommendation: str
    references: List[str]
    confidence: float
    detected_at: datetime

@dataclass
class ContractAnalysis:
    """Results of smart contract analysis"""
    contract_address: str
    contract_name: str
    source_code: str
    vulnerabilities: List[Vulnerability]
    gas_analysis: Dict[str, Any]
    complexity_metrics: Dict[str, Any]
    dependencies: List[str]
    analysis_timestamp: datetime
    overall_risk_score: float

class SmartContractScanner:
    """Advanced smart contract vulnerability scanner"""
    
    def __init__(self, config_file: str = None):
        """Initialize the vulnerability scanner"""
        self.vulnerability_patterns = self._load_vulnerability_patterns()
        self.defi_patterns = self._load_defi_patterns()
        self.gas_patterns = self._load_gas_patterns()
        self.known_exploits = self._load_known_exploits()
        
        if config_file:
            self._load_config(config_file)
    
    def _load_config(self, config_file: str):
        """Load scanner configuration"""
        try:
            with open(config_file, 'r') as f:
                config = json.load(f)
                # Update configuration settings
        except FileNotFoundError:
            print(f"Warning: Config file {config_file} not found")
    
    def _load_vulnerability_patterns(self) -> Dict[VulnerabilityType, Dict[str, Any]]:
        """Load vulnerability detection patterns"""
        return {
            VulnerabilityType.REENTRANCY: {
                'patterns': [
                    r'\.call\.value\([^)]*\)\([^)]*\)',
                    r'\.send\([^)]*\)',
                    r'\.transfer\([^)]*\)',
                    r'\.call\{value:[^}]*\}\([^)]*\)'
                ],
                'context_patterns': [
                    r'balances\[[^\]]*\]\s*=\s*0',
                    r'balances\[[^\]]*\]\s*-=',
                    r'require\(',
                    r'assert\('
                ],
                'severity': SeverityLevel.CRITICAL,
                'description': 'Potential reentrancy vulnerability detected',
                'recommendation': 'Use checks-effects-interactions pattern, reentrancy guard, or pull payment pattern'
            },
            VulnerabilityType.INTEGER_OVERFLOW: {
                'patterns': [
                    r'\+\+[a-zA-Z_][a-zA-Z0-9_]*',
                    r'[a-zA-Z_][a-zA-Z0-9_]*\+\+',
                    r'[a-zA-Z_][a-zA-Z0-9_]*\s*\+\s*[0-9]+',
                    r'[a-zA-Z_][a-zA-Z0-9_]*\s*\*\s*[0-9]+',
                    r'[a-zA-Z_][a-zA-Z0-9_]*\s*\-\s*[0-9]+'
                ],
                'severity': SeverityLevel.HIGH,
                'description': 'Potential integer overflow/underflow vulnerability',
                'recommendation': 'Use SafeMath library or Solidity 0.8+ built-in overflow checks'
            },
            VulnerabilityType.ACCESS_CONTROL: {
                'patterns': [
                    r'function\s+[a-zA-Z_][a-zA-Z0-9_]*\s*\([^)]*\)\s*public',
                    r'function\s+[a-zA-Z_][a-zA-Z0-9_]*\s*\([^)]*\)\s*external',
                    r'msg\.sender\s*==\s*owner',
                    r'onlyOwner',
                    r'require\(msg\.sender\s*=='
                ],
                'severity': SeverityLevel.HIGH,
                'description': 'Potential access control issue',
                'recommendation': 'Implement proper access control modifiers and role-based permissions'
            },
            VulnerabilityType.UNCHECKED_CALL: {
                'patterns': [
                    r'\.call\([^)]*\);?\s*$',
                    r'\.send\([^)]*\);?\s*$',
                    r'\.delegatecall\([^)]*\);?\s*$'
                ],
                'severity': SeverityLevel.MEDIUM,
                'description': 'Unchecked external call return value',
                'recommendation': 'Always check return values of external calls'
            },
            VulnerabilityType.TX_ORIGIN: {
                'patterns': [
                    r'tx\.origin',
                    r'require\(tx\.origin\s*==',
                    r'if\s*\(tx\.origin\s*=='
                ],
                'severity': SeverityLevel.MEDIUM,
                'description': 'Use of tx.origin for authorization',
                'recommendation': 'Use msg.sender instead of tx.origin for authorization'
            },
            VulnerabilityType.TIMESTAMP_DEPENDENCE: {
                'patterns': [
                    r'block\.timestamp',
                    r'now\s*[><=]',
                    r'block\.number\s*[><=]'
                ],
                'severity': SeverityLevel.LOW,
                'description': 'Dependence on block timestamp',
                'recommendation': 'Avoid using block.timestamp for critical logic or use it with caution'
            }
        }
    
    def _load_defi_patterns(self) -> Dict[str, Dict[str, Any]]:
        """Load DeFi-specific vulnerability patterns"""
        return {
            'flash_loan_attack': {
                'patterns': [
                    r'flashLoan\(',
                    r'executeOperation\(',
                    r'\.flashBorrow\(',
                    r'aave\.flashLoan\('
                ],
                'severity': SeverityLevel.CRITICAL,
                'description': 'Potential flash loan attack vector',
                'recommendation': 'Implement proper checks and balances for flash loan operations'
            },
            'oracle_manipulation': {
                'patterns': [
                    r'getPrice\(',
                    r'latestRoundData\(',
                    r'oracle\.price',
                    r'chainlink\.'
                ],
                'severity': SeverityLevel.HIGH,
                'description': 'Potential oracle manipulation vulnerability',
                'recommendation': 'Use multiple oracle sources and implement price deviation checks'
            },
            'governance_attack': {
                'patterns': [
                    r'propose\(',
                    r'vote\(',
                    r'execute\(',
                    r'governance\.'
                ],
                'severity': SeverityLevel.HIGH,
                'description': 'Potential governance attack vector',
                'recommendation': 'Implement proper governance controls and time delays'
            },
            'liquidity_manipulation': {
                'patterns': [
                    r'addLiquidity\(',
                    r'removeLiquidity\(',
                    r'swap\(',
                    r'getReserves\('
                ],
                'severity': SeverityLevel.MEDIUM,
                'description': 'Potential liquidity manipulation',
                'recommendation': 'Implement slippage protection and minimum liquidity requirements'
            }
        }
    
    def _load_gas_patterns(self) -> Dict[str, Any]:
        """Load gas optimization patterns"""
        return {
            'gas_limit_dos': {
                'patterns': [
                    r'for\s*\([^)]*;\s*[^;]*\.\s*length\s*;[^)]*\)',
                    r'while\s*\([^)]*\.\s*length\s*[><=]'
                ],
                'severity': SeverityLevel.MEDIUM,
                'description': 'Potential gas limit DoS attack',
                'recommendation': 'Avoid unbounded loops and implement pagination'
            },
            'inefficient_storage': {
                'patterns': [
                    r'storage\s+[a-zA-Z_][a-zA-Z0-9_]*\s*=',
                    r'\.push\([^)]*\)',
                    r'delete\s+[a-zA-Z_][a-zA-Z0-9_]*\['
                ],
                'severity': SeverityLevel.LOW,
                'description': 'Potentially inefficient storage operations',
                'recommendation': 'Optimize storage operations and use memory when appropriate'
            }
        }
    
    def _load_known_exploits(self) -> Dict[str, Dict[str, Any]]:
        """Load database of known exploits and attack patterns"""
        return {
            'dao_attack': {
                'description': 'The DAO reentrancy attack pattern',
                'pattern': r'splitDAO\(|withdrawRewardFor\(',
                'severity': SeverityLevel.CRITICAL,
                'year': 2016
            },
            'bec_overflow': {
                'description': 'BEC token integer overflow exploit',
                'pattern': r'batchTransfer\(',
                'severity': SeverityLevel.CRITICAL,
                'year': 2018
            },
            'compound_liquidation': {
                'description': 'Compound liquidation exploit pattern',
                'pattern': r'liquidateBorrow\(',
                'severity': SeverityLevel.HIGH,
                'year': 2020
            }
        }
    
    def scan_contract(self, source_code: str, contract_name: str = "Unknown", 
                     contract_address: str = "") -> ContractAnalysis:
        """Perform comprehensive security analysis of a smart contract"""
        
        vulnerabilities = []
        
        # Detect standard vulnerabilities
        vulnerabilities.extend(self._detect_vulnerabilities(source_code))
        
        # Detect DeFi-specific vulnerabilities
        vulnerabilities.extend(self._detect_defi_vulnerabilities(source_code))
        
        # Detect gas-related issues
        vulnerabilities.extend(self._detect_gas_issues(source_code))
        
        # Check against known exploits
        vulnerabilities.extend(self._check_known_exploits(source_code))
        
        # Analyze gas usage patterns
        gas_analysis = self._analyze_gas_usage(source_code)
        
        # Calculate complexity metrics
        complexity_metrics = self._calculate_complexity(source_code)
        
        # Extract dependencies
        dependencies = self._extract_dependencies(source_code)
        
        # Calculate overall risk score
        risk_score = self._calculate_risk_score(vulnerabilities)
        
        return ContractAnalysis(
            contract_address=contract_address,
            contract_name=contract_name,
            source_code=source_code,
            vulnerabilities=vulnerabilities,
            gas_analysis=gas_analysis,
            complexity_metrics=complexity_metrics,
            dependencies=dependencies,
            analysis_timestamp=datetime.now(),
            overall_risk_score=risk_score
        )
    
    def _detect_vulnerabilities(self, source_code: str) -> List[Vulnerability]:
        """Detect standard smart contract vulnerabilities"""
        vulnerabilities = []
        lines = source_code.split('\n')
        
        for vuln_type, pattern_info in self.vulnerability_patterns.items():
            for pattern in pattern_info['patterns']:
                matches = re.finditer(pattern, source_code, re.MULTILINE | re.IGNORECASE)
                
                for match in matches:
                    # Find line number and context
                    line_num = source_code[:match.start()].count('\n') + 1
                    line_content = lines[line_num - 1] if line_num <= len(lines) else ""
                    
                    # Additional context analysis
                    confidence = self._calculate_confidence(
                        source_code, match, vuln_type, pattern_info
                    )
                    
                    if confidence > 0.5:  # Only report high-confidence vulnerabilities
                        vuln_id = self._generate_vuln_id(vuln_type, line_num)
                        
                        vulnerability = Vulnerability(
                            vuln_id=vuln_id,
                            vuln_type=vuln_type,
                            severity=pattern_info['severity'],
                            title=f"{vuln_type.value.replace('_', ' ').title()} Vulnerability",
                            description=pattern_info['description'],
                            location={
                                'line': line_num,
                                'column': match.start() - source_code.rfind('\n', 0, match.start()),
                                'function': self._extract_function_name(source_code, match.start())
                            },
                            code_snippet=line_content.strip(),
                            recommendation=pattern_info['recommendation'],
                            references=self._get_vulnerability_references(vuln_type),
                            confidence=confidence,
                            detected_at=datetime.now()
                        )
                        
                        vulnerabilities.append(vulnerability)
        
        return vulnerabilities
    
    def _detect_defi_vulnerabilities(self, source_code: str) -> List[Vulnerability]:
        """Detect DeFi-specific vulnerabilities"""
        vulnerabilities = []
        lines = source_code.split('\n')
        
        for vuln_name, pattern_info in self.defi_patterns.items():
            for pattern in pattern_info['patterns']:
                matches = re.finditer(pattern, source_code, re.MULTILINE | re.IGNORECASE)
                
                for match in matches:
                    line_num = source_code[:match.start()].count('\n') + 1
                    line_content = lines[line_num - 1] if line_num <= len(lines) else ""
                    
                    # DeFi-specific confidence calculation
                    confidence = self._calculate_defi_confidence(source_code, match, vuln_name)
                    
                    if confidence > 0.4:  # Lower threshold for DeFi vulnerabilities
                        vuln_id = self._generate_vuln_id(vuln_name, line_num)
                        
                        vulnerability = Vulnerability(
                            vuln_id=vuln_id,
                            vuln_type=VulnerabilityType.FLASH_LOAN_ATTACK,  # Map to closest standard type
                            severity=pattern_info['severity'],
                            title=f"DeFi {vuln_name.replace('_', ' ').title()} Vulnerability",
                            description=pattern_info['description'],
                            location={
                                'line': line_num,
                                'column': match.start() - source_code.rfind('\n', 0, match.start()),
                                'function': self._extract_function_name(source_code, match.start())
                            },
                            code_snippet=line_content.strip(),
                            recommendation=pattern_info['recommendation'],
                            references=self._get_defi_references(vuln_name),
                            confidence=confidence,
                            detected_at=datetime.now()
                        )
                        
                        vulnerabilities.append(vulnerability)
        
        return vulnerabilities
    
    def _detect_gas_issues(self, source_code: str) -> List[Vulnerability]:
        """Detect gas-related vulnerabilities and inefficiencies"""
        vulnerabilities = []
        lines = source_code.split('\n')
        
        for issue_name, pattern_info in self.gas_patterns.items():
            for pattern in pattern_info['patterns']:
                matches = re.finditer(pattern, source_code, re.MULTILINE | re.IGNORECASE)
                
                for match in matches:
                    line_num = source_code[:match.start()].count('\n') + 1
                    line_content = lines[line_num - 1] if line_num <= len(lines) else ""
                    
                    vuln_id = self._generate_vuln_id(issue_name, line_num)
                    
                    vulnerability = Vulnerability(
                        vuln_id=vuln_id,
                        vuln_type=VulnerabilityType.DENIAL_OF_SERVICE,
                        severity=pattern_info['severity'],
                        title=f"Gas {issue_name.replace('_', ' ').title()} Issue",
                        description=pattern_info['description'],
                        location={
                            'line': line_num,
                            'column': match.start() - source_code.rfind('\n', 0, match.start()),
                            'function': self._extract_function_name(source_code, match.start())
                        },
                        code_snippet=line_content.strip(),
                        recommendation=pattern_info['recommendation'],
                        references=[],
                        confidence=0.8,
                        detected_at=datetime.now()
                    )
                    
                    vulnerabilities.append(vulnerability)
        
        return vulnerabilities
    
    def _check_known_exploits(self, source_code: str) -> List[Vulnerability]:
        """Check against known exploit patterns"""
        vulnerabilities = []
        lines = source_code.split('\n')
        
        for exploit_name, exploit_info in self.known_exploits.items():
            pattern = exploit_info['pattern']
            matches = re.finditer(pattern, source_code, re.MULTILINE | re.IGNORECASE)
            
            for match in matches:
                line_num = source_code[:match.start()].count('\n') + 1
                line_content = lines[line_num - 1] if line_num <= len(lines) else ""
                
                vuln_id = self._generate_vuln_id(exploit_name, line_num)
                
                vulnerability = Vulnerability(
                    vuln_id=vuln_id,
                    vuln_type=VulnerabilityType.REENTRANCY,  # Default mapping
                    severity=exploit_info['severity'],
                    title=f"Known Exploit Pattern: {exploit_name}",
                    description=f"Similar pattern to {exploit_info['description']} ({exploit_info['year']})",
                    location={
                        'line': line_num,
                        'column': match.start() - source_code.rfind('\n', 0, match.start()),
                        'function': self._extract_function_name(source_code, match.start())
                    },
                    code_snippet=line_content.strip(),
                    recommendation="Review this pattern carefully against historical exploits",
                    references=[f"Historical exploit: {exploit_name} ({exploit_info['year']})"],
                    confidence=0.9,
                    detected_at=datetime.now()
                )
                
                vulnerabilities.append(vulnerability)
        
        return vulnerabilities
    
    def _calculate_confidence(self, source_code: str, match: re.Match, 
                            vuln_type: VulnerabilityType, pattern_info: Dict) -> float:
        """Calculate confidence score for a vulnerability detection"""
        base_confidence = 0.6
        
        # Check for mitigating patterns
        context_around_match = self._get_context(source_code, match.start(), 200)
        
        if vuln_type == VulnerabilityType.REENTRANCY:
            # Check for reentrancy guards
            if re.search(r'nonReentrant|ReentrancyGuard|mutex', context_around_match):
                base_confidence -= 0.3
            # Check for checks-effects-interactions pattern
            if re.search(r'require\(.*balance.*\)', context_around_match):
                base_confidence += 0.2
        
        elif vuln_type == VulnerabilityType.INTEGER_OVERFLOW:
            # Check for SafeMath usage
            if re.search(r'SafeMath|using.*for.*uint', source_code):
                base_confidence -= 0.4
            # Check for Solidity 0.8+ (built-in overflow checks)
            if re.search(r'pragma solidity.*0\.8', source_code):
                base_confidence -= 0.5
        
        elif vuln_type == VulnerabilityType.ACCESS_CONTROL:
            # Check for proper modifiers
            if re.search(r'modifier\s+onlyOwner|modifier\s+onlyAdmin', source_code):
                base_confidence -= 0.2
        
        return max(0.0, min(1.0, base_confidence))
    
    def _calculate_defi_confidence(self, source_code: str, match: re.Match, vuln_name: str) -> float:
        """Calculate confidence for DeFi-specific vulnerabilities"""
        base_confidence = 0.5
        
        context = self._get_context(source_code, match.start(), 300)
        
        if vuln_name == 'flash_loan_attack':
            # Look for proper checks
            if re.search(r'require\(.*balance.*\)|assert\(.*balance.*\)', context):
                base_confidence += 0.3
            if re.search(r'fee|premium', context):
                base_confidence -= 0.2
        
        elif vuln_name == 'oracle_manipulation':
            # Check for multiple oracle sources
            if re.search(r'oracle1|oracle2|average|median', context):
                base_confidence -= 0.3
            if re.search(r'deviation|threshold', context):
                base_confidence -= 0.2
        
        return max(0.0, min(1.0, base_confidence))
    
    def _analyze_gas_usage(self, source_code: str) -> Dict[str, Any]:
        """Analyze gas usage patterns in the contract"""
        analysis = {
            'potential_gas_issues': 0,
            'loops_detected': 0,
            'storage_operations': 0,
            'external_calls': 0,
            'estimated_deployment_gas': 0
        }
        
        # Count loops (potential gas issues)
        loop_patterns = [r'for\s*\(', r'while\s*\(', r'do\s*{']
        for pattern in loop_patterns:
            analysis['loops_detected'] += len(re.findall(pattern, source_code))
        
        # Count storage operations
        storage_patterns = [r'\.push\(', r'delete\s+\w+', r'\w+\[\w+\]\s*=']
        for pattern in storage_patterns:
            analysis['storage_operations'] += len(re.findall(pattern, source_code))
        
        # Count external calls
        call_patterns = [r'\.call\(', r'\.send\(', r'\.transfer\(', r'\.delegatecall\(']
        for pattern in call_patterns:
            analysis['external_calls'] += len(re.findall(pattern, source_code))
        
        # Rough gas estimation (very simplified)
        lines_of_code = len([line for line in source_code.split('\n') if line.strip()])
        analysis['estimated_deployment_gas'] = lines_of_code * 1000  # Very rough estimate
        
        analysis['potential_gas_issues'] = (
            analysis['loops_detected'] * 2 +
            analysis['storage_operations'] +
            analysis['external_calls']
        )
        
        return analysis
    
    def _calculate_complexity(self, source_code: str) -> Dict[str, Any]:
        """Calculate code complexity metrics"""
        lines = source_code.split('\n')
        
        metrics = {
            'total_lines': len(lines),
            'code_lines': len([line for line in lines if line.strip() and not line.strip().startswith('//')]),
            'functions': len(re.findall(r'function\s+\w+', source_code)),
            'modifiers': len(re.findall(r'modifier\s+\w+', source_code)),
            'events': len(re.findall(r'event\s+\w+', source_code)),
            'inheritance_depth': len(re.findall(r'is\s+\w+', source_code)),
            'cyclomatic_complexity': self._calculate_cyclomatic_complexity(source_code)
        }
        
        return metrics
    
    def _calculate_cyclomatic_complexity(self, source_code: str) -> int:
        """Calculate cyclomatic complexity of the contract"""
        # Count decision points
        decision_patterns = [
            r'\bif\s*\(',
            r'\bfor\s*\(',
            r'\bwhile\s*\(',
            r'\?\s*.*:',  # Ternary operator
            r'\b&&\b',
            r'\b\|\|\b',
            r'\bcatch\s*\('
        ]
        
        complexity = 1  # Base complexity
        for pattern in decision_patterns:
            complexity += len(re.findall(pattern, source_code))
        
        return complexity
    
    def _extract_dependencies(self, source_code: str) -> List[str]:
        """Extract contract dependencies and imports"""
        dependencies = []
        
        # Find import statements
        import_matches = re.findall(r'import\s+["\']([^"\']+)["\']', source_code)
        dependencies.extend(import_matches)
        
        # Find inheritance relationships
        inheritance_matches = re.findall(r'contract\s+\w+\s+is\s+([\w\s,]+)', source_code)
        for match in inheritance_matches:
            parents = [parent.strip() for parent in match.split(',')]
            dependencies.extend(parents)
        
        return list(set(dependencies))  # Remove duplicates
    
    def _calculate_risk_score(self, vulnerabilities: List[Vulnerability]) -> float:
        """Calculate overall risk score based on vulnerabilities"""
        if not vulnerabilities:
            return 0.0
        
        severity_weights = {
            SeverityLevel.CRITICAL: 10.0,
            SeverityLevel.HIGH: 7.0,
            SeverityLevel.MEDIUM: 4.0,
            SeverityLevel.LOW: 2.0,
            SeverityLevel.INFORMATIONAL: 1.0
        }
        
        total_score = 0.0
        total_weight = 0.0
        
        for vuln in vulnerabilities:
            weight = severity_weights[vuln.severity]
            score = weight * vuln.confidence
            total_score += score
            total_weight += weight
        
        # Normalize to 0-10 scale
        if total_weight > 0:
            normalized_score = min(10.0, (total_score / total_weight) * (len(vulnerabilities) / 5.0))
        else:
            normalized_score = 0.0
        
        return round(normalized_score, 2)
    
    def _generate_vuln_id(self, vuln_type: Any, line_num: int) -> str:
        """Generate unique vulnerability ID"""
        vuln_name = str(vuln_type).replace('VulnerabilityType.', '').replace('.', '_')
        timestamp = datetime.now().strftime('%Y%m%d%H%M%S')
        return f"VULN-{vuln_name}-{line_num}-{timestamp}"
    
    def _extract_function_name(self, source_code: str, position: int) -> str:
        """Extract the function name where the vulnerability was found"""
        # Look backwards for function declaration
        text_before = source_code[:position]
        function_matches = list(re.finditer(r'function\s+(\w+)', text_before))
        
        if function_matches:
            return function_matches[-1].group(1)
        
        return "unknown"
    
    def _get_context(self, source_code: str, position: int, context_size: int) -> str:
        """Get code context around a position"""
        start = max(0, position - context_size)
        end = min(len(source_code), position + context_size)
        return source_code[start:end]
    
    def _get_vulnerability_references(self, vuln_type: VulnerabilityType) -> List[str]:
        """Get reference links for vulnerability types"""
        references = {
            VulnerabilityType.REENTRANCY: [
                "https://swcregistry.io/docs/SWC-107",
                "https://consensys.github.io/smart-contract-best-practices/attacks/reentrancy/"
            ],
            VulnerabilityType.INTEGER_OVERFLOW: [
                "https://swcregistry.io/docs/SWC-101",
                "https://consensys.github.io/smart-contract-best-practices/attacks/insecure-arithmetic/"
            ],
            VulnerabilityType.ACCESS_CONTROL: [
                "https://swcregistry.io/docs/SWC-115",
                "https://consensys.github.io/smart-contract-best-practices/general/access-control/"
            ]
        }
        
        return references.get(vuln_type, [])
    
    def _get_defi_references(self, vuln_name: str) -> List[str]:
        """Get reference links for DeFi vulnerabilities"""
        references = {
            'flash_loan_attack': [
                "https://consensys.net/blog/cryptocurrency/flash-loan-attack-on-defi/"
            ],
            'oracle_manipulation': [
                "https://blog.chain.link/flash-loans-and-the-importance-of-tamper-proof-oracles/"
            ]
        }
        
        return references.get(vuln_name, [])
    
    def generate_report(self, analysis: ContractAnalysis) -> Dict[str, Any]:
        """Generate comprehensive security analysis report"""
        
        # Group vulnerabilities by severity
        vuln_by_severity = {}
        for severity in SeverityLevel:
            vuln_by_severity[severity.value] = [
                v for v in analysis.vulnerabilities if v.severity == severity
            ]
        
        # Calculate statistics
        stats = {
            'total_vulnerabilities': len(analysis.vulnerabilities),
            'critical_count': len(vuln_by_severity['critical']),
            'high_count': len(vuln_by_severity['high']),
            'medium_count': len(vuln_by_severity['medium']),
            'low_count': len(vuln_by_severity['low']),
            'info_count': len(vuln_by_severity['informational'])
        }
        
        # Risk assessment
        if analysis.overall_risk_score >= 8.0:
            risk_level = "CRITICAL"
        elif analysis.overall_risk_score >= 6.0:
            risk_level = "HIGH"
        elif analysis.overall_risk_score >= 4.0:
            risk_level = "MEDIUM"
        elif analysis.overall_risk_score >= 2.0:
            risk_level = "LOW"
        else:
            risk_level = "MINIMAL"
        
        report = {
            'contract_info': {
                'name': analysis.contract_name,
                'address': analysis.contract_address,
                'analyzed_at': analysis.analysis_timestamp.isoformat()
            },
            'security_summary': {
                'overall_risk_score': analysis.overall_risk_score,
                'risk_level': risk_level,
                'vulnerabilities_found': stats['total_vulnerabilities'],
                'critical_issues': stats['critical_count'],
                'recommendation': self._get_overall_recommendation(risk_level, stats)
            },
            'vulnerability_breakdown': stats,
            'detailed_findings': [
                {
                    'id': v.vuln_id,
                    'type': v.vuln_type.value,
                    'severity': v.severity.value,
                    'title': v.title,
                    'description': v.description,
                    'location': v.location,
                    'code_snippet': v.code_snippet,
                    'recommendation': v.recommendation,
                    'confidence': v.confidence,
                    'references': v.references
                }
                for v in analysis.vulnerabilities
            ],
            'code_quality': {
                'complexity_metrics': analysis.complexity_metrics,
                'gas_analysis': analysis.gas_analysis,
                'dependencies': analysis.dependencies
            },
            'recommendations': self._generate_recommendations(analysis),
            'generated_at': datetime.now().isoformat()
        }
        
        return report
    
    def _get_overall_recommendation(self, risk_level: str, stats: Dict) -> str:
        """Get overall security recommendation"""
        if risk_level == "CRITICAL":
            return "DO NOT DEPLOY - Critical security issues must be resolved immediately"
        elif risk_level == "HIGH":
            return "HIGH RISK - Significant security issues require immediate attention"
        elif risk_level == "MEDIUM":
            return "MEDIUM RISK - Security improvements recommended before deployment"
        elif risk_level == "LOW":
            return "LOW RISK - Minor security improvements suggested"
        else:
            return "MINIMAL RISK - Contract appears to follow good security practices"
    
    def _generate_recommendations(self, analysis: ContractAnalysis) -> List[str]:
        """Generate security recommendations"""
        recommendations = []
        
        # Based on vulnerabilities found
        vuln_types = [v.vuln_type for v in analysis.vulnerabilities]
        
        if VulnerabilityType.REENTRANCY in vuln_types:
            recommendations.append("Implement reentrancy guards on all external-calling functions")
        
        if VulnerabilityType.INTEGER_OVERFLOW in vuln_types:
            recommendations.append("Use SafeMath library or upgrade to Solidity 0.8+")
        
        if VulnerabilityType.ACCESS_CONTROL in vuln_types:
            recommendations.append("Implement proper access control with role-based permissions")
        
        # Based on complexity
        if analysis.complexity_metrics['cyclomatic_complexity'] > 20:
            recommendations.append("Consider breaking down complex functions to improve readability")
        
        # Based on gas analysis
        if analysis.gas_analysis['loops_detected'] > 5:
            recommendations.append("Review loops for potential gas limit DoS attacks")
        
        if not recommendations:
            recommendations.append("Continue following security best practices")
        
        return recommendations
    
    def export_report(self, report: Dict[str, Any], format: str = 'json', 
                     filename: str = None) -> str:
        """Export security analysis report"""
        if not filename:
            timestamp = datetime.now().strftime("%Y%m%d_%H%M%S")
            contract_name = report['contract_info']['name'].replace(' ', '_')
            filename = f"security_analysis_{contract_name}_{timestamp}.{format}"
        
        if format == 'json':
            with open(filename, 'w') as f:
                json.dump(report, f, indent=2, default=str)
        
        return filename

# Example usage and testing
if __name__ == "__main__":
    print("🔒 Smart Contract Vulnerability Scanner")
    print("=" * 50)
    
    # Initialize scanner
    scanner = SmartContractScanner()
    
    # Example Solidity contract with vulnerabilities
    vulnerable_contract = '''
    pragma solidity ^0.8.0;
    
    contract VulnerableContract {
        mapping(address => uint256) public balances;
        
        function withdraw(uint256 amount) public {
            require(balances[msg.sender] >= amount);
            
            // Vulnerable to reentrancy
            msg.sender.call{value: amount}("");
            
            balances[msg.sender] -= amount;
        }
        
        function deposit() public payable {
            balances[msg.sender] += msg.value;
        }
        
        // Vulnerable to access control issues
        function emergencyWithdraw() public {
            if (tx.origin == owner) {  // Bad use of tx.origin
                payable(owner).transfer(address(this).balance);
            }
        }
        
        address public owner = msg.sender;
    }
    '''
    
    # Scan the contract
    analysis = scanner.scan_contract(vulnerable_contract, "VulnerableContract", "0x123...")
    
    print(f"Analysis completed for {analysis.contract_name}")
    print(f"Vulnerabilities found: {len(analysis.vulnerabilities)}")
    print(f"Overall risk score: {analysis.overall_risk_score}/10")
    
    # Generate and display report
    report = scanner.generate_report(analysis)
    print(f"Risk Level: {report['security_summary']['risk_level']}")
    print(f"Recommendation: {report['security_summary']['recommendation']}")
    
    print("\n✅ Smart contract scanner initialized successfully!")
    print("Ready to analyze Solidity contracts for security vulnerabilities.")