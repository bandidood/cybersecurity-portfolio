"""
Static Malware Analyzer
Performs static analysis on malware samples without execution
"""

import re
import math
import hashlib
import magic
from pathlib import Path
from typing import Optional, List, Tuple
from datetime import datetime
import time

try:
    import pefile
    PE_AVAILABLE = True
except ImportError:
    PE_AVAILABLE = False

from ..models import (
    FileInfo, PEInfo, StringAnalysis, StaticAnalysisResult,
    SampleType, ThreatLevel
)


class StaticAnalyzer:
    """
    Static malware analysis engine
    Analyzes files without execution
    """

    def __init__(self):
        self.min_string_length = 4
        self.max_strings = 1000

    def analyze_file(self, filepath: str) -> StaticAnalysisResult:
        """
        Perform complete static analysis on file

        Args:
            filepath: Path to file to analyze

        Returns:
            StaticAnalysisResult with analysis findings
        """
        start_time = time.time()

        # Get file information
        file_info = self._extract_file_info(filepath)

        # Determine sample type
        sample_type = self._determine_sample_type(file_info)

        # Extract strings
        string_analysis = self._analyze_strings(filepath)

        # PE-specific analysis
        pe_info = None
        if sample_type in [SampleType.PE_EXECUTABLE, SampleType.PE_DLL]:
            pe_info = self._analyze_pe(filepath)

        # Calculate threat score
        threat_score, threat_level = self._calculate_threat_score(
            file_info, pe_info, string_analysis
        )

        # Extract indicators
        indicators = self._extract_indicators(string_analysis, pe_info)

        # Generate tags
        tags = self._generate_tags(pe_info, string_analysis, indicators)

        # Try to identify family
        family = self._identify_family(tags, indicators)

        analysis_time = time.time() - start_time

        return StaticAnalysisResult(
            file_info=file_info,
            sample_type=sample_type,
            pe_info=pe_info,
            string_analysis=string_analysis,
            threat_level=threat_level,
            threat_score=threat_score,
            indicators=indicators,
            tags=tags,
            family=family,
            analysis_time=analysis_time
        )

    def _extract_file_info(self, filepath: str) -> FileInfo:
        """Extract basic file information"""
        path = Path(filepath)

        with open(filepath, 'rb') as f:
            data = f.read()

        # Calculate hashes
        md5 = hashlib.md5(data).hexdigest()
        sha1 = hashlib.sha1(data).hexdigest()
        sha256 = hashlib.sha256(data).hexdigest()

        # Get file type
        try:
            file_magic = magic.from_file(filepath)
            mime_type = magic.from_file(filepath, mime=True)
        except:
            file_magic = "Unknown"
            mime_type = "application/octet-stream"

        return FileInfo(
            filename=path.name,
            filepath=str(path.absolute()),
            size=len(data),
            md5=md5,
            sha1=sha1,
            sha256=sha256,
            file_type=self._get_file_extension(path.name),
            mime_type=mime_type,
            magic=file_magic
        )

    def _determine_sample_type(self, file_info: FileInfo) -> SampleType:
        """Determine the type of malware sample"""
        magic_lower = file_info.magic.lower()
        ext = file_info.file_type.lower()

        if 'pe32' in magic_lower or 'ms-dos executable' in magic_lower:
            if ext == 'dll' or 'dll' in magic_lower:
                return SampleType.PE_DLL
            return SampleType.PE_EXECUTABLE

        if 'elf' in magic_lower:
            return SampleType.ELF

        if 'mach-o' in magic_lower:
            return SampleType.MACH_O

        if ext in ['py', 'js', 'vbs', 'ps1', 'sh', 'bat', 'cmd']:
            return SampleType.SCRIPT

        if ext in ['doc', 'docx', 'xls', 'xlsx', 'pdf', 'rtf']:
            return SampleType.DOCUMENT

        if ext in ['zip', 'rar', '7z', 'tar', 'gz']:
            return SampleType.ARCHIVE

        if ext == 'apk':
            return SampleType.APK

        return SampleType.UNKNOWN

    def _analyze_strings(self, filepath: str) -> StringAnalysis:
        """Extract and analyze strings from file"""
        with open(filepath, 'rb') as f:
            data = f.read()

        # Extract ASCII strings
        ascii_pattern = rb'[\x20-\x7E]{4,}'
        ascii_strings = [s.decode('ascii') for s in re.findall(ascii_pattern, data)]

        # Extract Unicode strings (UTF-16LE)
        unicode_pattern = rb'(?:[\x20-\x7E]\x00){4,}'
        unicode_strings = [
            s.decode('utf-16le', errors='ignore')
            for s in re.findall(unicode_pattern, data)
        ]

        # Combine and limit
        all_strings = list(set(ascii_strings + unicode_strings))[:self.max_strings]

        # Extract specific patterns
        urls = self._extract_urls(all_strings)
        ips = self._extract_ips(all_strings)
        emails = self._extract_emails(all_strings)
        registry_keys = self._extract_registry_keys(all_strings)
        file_paths = self._extract_file_paths(all_strings)
        crypto_constants = self._extract_crypto_constants(all_strings)
        suspicious_strings = self._extract_suspicious_strings(all_strings)

        return StringAnalysis(
            ascii_strings=ascii_strings[:500],
            unicode_strings=unicode_strings[:500],
            urls=urls,
            ips=ips,
            emails=emails,
            registry_keys=registry_keys,
            file_paths=file_paths,
            crypto_constants=crypto_constants,
            suspicious_strings=suspicious_strings
        )

    def _analyze_pe(self, filepath: str) -> Optional[PEInfo]:
        """Analyze PE (Portable Executable) file"""
        if not PE_AVAILABLE:
            return None

        try:
            pe = pefile.PE(filepath)

            # Basic info
            architecture = "x64" if pe.FILE_HEADER.Machine == 0x8664 else "x86"
            subsystem = pefile.SUBSYSTEM_TYPE.get(
                pe.OPTIONAL_HEADER.Subsystem, "UNKNOWN"
            )

            # Compilation timestamp
            try:
                comp_timestamp = datetime.fromtimestamp(pe.FILE_HEADER.TimeDateStamp)
            except:
                comp_timestamp = None

            # Entry point and image base
            entry_point = pe.OPTIONAL_HEADER.AddressOfEntryPoint
            image_base = pe.OPTIONAL_HEADER.ImageBase

            # Sections
            sections = []
            total_entropy = 0
            for section in pe.sections:
                entropy = self._calculate_entropy(section.get_data())
                total_entropy += entropy
                sections.append({
                    'name': section.Name.decode('utf-8', errors='ignore').strip('\x00'),
                    'virtual_address': hex(section.VirtualAddress),
                    'virtual_size': section.Misc_VirtualSize,
                    'raw_size': section.SizeOfRawData,
                    'entropy': round(entropy, 2),
                    'characteristics': hex(section.Characteristics)
                })

            avg_entropy = total_entropy / len(sections) if sections else 0

            # Imports
            imports = []
            if hasattr(pe, 'DIRECTORY_ENTRY_IMPORT'):
                for entry in pe.DIRECTORY_ENTRY_IMPORT:
                    dll_name = entry.dll.decode('utf-8', errors='ignore')
                    functions = [
                        imp.name.decode('utf-8', errors='ignore')
                        for imp in entry.imports
                        if imp.name
                    ]
                    imports.append({dll_name: functions[:50]})  # Limit functions

            # Exports
            exports = []
            if hasattr(pe, 'DIRECTORY_ENTRY_EXPORT'):
                for exp in pe.DIRECTORY_ENTRY_EXPORT.symbols:
                    if exp.name:
                        exports.append(exp.name.decode('utf-8', errors='ignore'))

            # Check for packing
            is_packed, packer = self._detect_packing(pe, avg_entropy, sections)

            # Resources
            resources = []
            if hasattr(pe, 'DIRECTORY_ENTRY_RESOURCE'):
                for res_type in pe.DIRECTORY_ENTRY_RESOURCE.entries:
                    if hasattr(res_type, 'directory'):
                        for res_id in res_type.directory.entries:
                            if hasattr(res_id, 'directory'):
                                for res_lang in res_id.directory.entries:
                                    resources.append({
                                        'type': pefile.RESOURCE_TYPE.get(
                                            res_type.id, 'UNKNOWN'
                                        ),
                                        'id': res_id.id if hasattr(res_id, 'id') else 0,
                                        'lang': res_lang.data.lang if hasattr(res_lang, 'data') else 0
                                    })

            pe.close()

            return PEInfo(
                architecture=architecture,
                subsystem=subsystem,
                compilation_timestamp=comp_timestamp,
                entry_point=entry_point,
                image_base=image_base,
                sections=sections,
                imports=imports,
                exports=exports,
                resources=resources[:20],  # Limit resources
                is_packed=is_packed,
                packer=packer,
                entropy=round(avg_entropy, 2)
            )

        except Exception as e:
            print(f"Error analyzing PE: {e}")
            return None

    def _calculate_entropy(self, data: bytes) -> float:
        """Calculate Shannon entropy of data"""
        if not data:
            return 0.0

        entropy = 0
        for x in range(256):
            p_x = data.count(bytes([x])) / len(data)
            if p_x > 0:
                entropy += - p_x * math.log2(p_x)

        return entropy

    def _detect_packing(
        self, pe, avg_entropy: float, sections: List
    ) -> Tuple[bool, Optional[str]]:
        """Detect if PE is packed and identify packer"""
        # High entropy indicates packing/encryption
        if avg_entropy > 7.0:
            # Check for common packer signatures
            for section in sections:
                name = section['name'].upper()
                if name in ['UPX0', 'UPX1', 'UPX2']:
                    return True, "UPX"
                elif 'ASPACK' in name:
                    return True, "ASPack"
                elif 'PECLOAK' in name:
                    return True, "PECompact"
                elif '.MPRESS' in name:
                    return True, "MPRESS"

            return True, "Unknown Packer"

        return False, None

    def _calculate_threat_score(
        self,
        file_info: FileInfo,
        pe_info: Optional[PEInfo],
        string_analysis: StringAnalysis
    ) -> Tuple[float, ThreatLevel]:
        """Calculate overall threat score"""
        score = 0.0

        # File size (very small or very large)
        if file_info.size < 10000 or file_info.size > 10000000:
            score += 10

        # PE analysis
        if pe_info:
            # Packing
            if pe_info.is_packed:
                score += 30

            # High entropy
            if pe_info.entropy > 7.0:
                score += 20

            # Suspicious imports
            suspicious_imports = ['CreateRemoteThread', 'VirtualAllocEx', 'WriteProcessMemory',
                                  'SetWindowsHookEx', 'GetProcAddress', 'LoadLibrary']
            for import_dict in pe_info.imports:
                for dll, functions in import_dict.items():
                    for func in functions:
                        if any(sus in func for sus in suspicious_imports):
                            score += 5

        # String analysis
        if string_analysis.urls:
            score += len(string_analysis.urls) * 5

        if string_analysis.ips:
            score += len(string_analysis.ips) * 3

        if string_analysis.suspicious_strings:
            score += len(string_analysis.suspicious_strings) * 2

        # Limit to 100
        score = min(score, 100.0)

        # Determine threat level
        if score < 25:
            threat_level = ThreatLevel.BENIGN
        elif score < 50:
            threat_level = ThreatLevel.SUSPICIOUS
        elif score < 75:
            threat_level = ThreatLevel.MALICIOUS
        else:
            threat_level = ThreatLevel.HIGHLY_MALICIOUS

        return score, threat_level

    def _extract_indicators(
        self, string_analysis: StringAnalysis, pe_info: Optional[PEInfo]
    ) -> List[str]:
        """Extract IOCs from analysis"""
        indicators = []

        # Add IPs and URLs
        indicators.extend(string_analysis.ips)
        indicators.extend(string_analysis.urls)

        # Add suspicious strings as potential indicators
        indicators.extend(string_analysis.suspicious_strings[:10])

        return list(set(indicators))

    def _generate_tags(
        self,
        pe_info: Optional[PEInfo],
        string_analysis: StringAnalysis,
        indicators: List[str]
    ) -> List[str]:
        """Generate classification tags"""
        tags = []

        if pe_info:
            if pe_info.is_packed:
                tags.append('packed')
            if pe_info.packer:
                tags.append(f'packer:{pe_info.packer.lower()}')
            if pe_info.architecture:
                tags.append(f'arch:{pe_info.architecture}')

        if string_analysis.urls:
            tags.append('network-activity')
        if string_analysis.registry_keys:
            tags.append('registry-modification')
        if len(indicators) > 5:
            tags.append('high-ioc-count')

        # Check for specific malware indicators
        suspicious = ' '.join(string_analysis.suspicious_strings).lower()
        if 'ransom' in suspicious or 'decrypt' in suspicious:
            tags.append('potential-ransomware')
        if 'backdoor' in suspicious or 'cmd' in suspicious or 'shell' in suspicious:
            tags.append('potential-backdoor')
        if 'keylog' in suspicious:
            tags.append('potential-keylogger')

        return tags

    def _identify_family(self, tags: List[str], indicators: List[str]) -> Optional[str]:
        """Attempt to identify malware family"""
        # Basic family identification based on patterns
        tags_str = ' '.join(tags).lower()

        if 'wannacry' in tags_str or 'wcry' in tags_str:
            return "WannaCry"
        if 'emotet' in tags_str:
            return "Emotet"
        if 'trickbot' in tags_str:
            return "TrickBot"
        if 'potential-ransomware' in tags:
            return "Generic.Ransomware"
        if 'potential-backdoor' in tags:
            return "Generic.Backdoor"

        return None

    def _get_file_extension(self, filename: str) -> str:
        """Get file extension"""
        return Path(filename).suffix.lstrip('.')

    def _extract_urls(self, strings: List[str]) -> List[str]:
        """Extract URLs from strings"""
        url_pattern = re.compile(
            r'https?://[^\s<>"{}|\\^`\[\]]+',
            re.IGNORECASE
        )
        urls = []
        for s in strings:
            urls.extend(url_pattern.findall(s))
        return list(set(urls))[:50]

    def _extract_ips(self, strings: List[str]) -> List[str]:
        """Extract IP addresses from strings"""
        ip_pattern = re.compile(
            r'\b(?:[0-9]{1,3}\.){3}[0-9]{1,3}\b'
        )
        ips = []
        for s in strings:
            ips.extend(ip_pattern.findall(s))
        # Filter out invalid IPs
        valid_ips = [ip for ip in ips if all(0 <= int(octet) <= 255 for octet in ip.split('.'))]
        return list(set(valid_ips))[:50]

    def _extract_emails(self, strings: List[str]) -> List[str]:
        """Extract email addresses from strings"""
        email_pattern = re.compile(
            r'\b[A-Za-z0-9._%+-]+@[A-Za-z0-9.-]+\.[A-Z|a-z]{2,}\b'
        )
        emails = []
        for s in strings:
            emails.extend(email_pattern.findall(s))
        return list(set(emails))[:20]

    def _extract_registry_keys(self, strings: List[str]) -> List[str]:
        """Extract Windows registry keys"""
        reg_pattern = re.compile(
            r'(?:HKEY_[A-Z_]+|HKLM|HKCU)\\[^\s"<>|]+',
            re.IGNORECASE
        )
        keys = []
        for s in strings:
            keys.extend(reg_pattern.findall(s))
        return list(set(keys))[:30]

    def _extract_file_paths(self, strings: List[str]) -> List[str]:
        """Extract file paths"""
        path_patterns = [
            re.compile(r'[A-Z]:\\[^\s"<>|*?]+', re.IGNORECASE),  # Windows paths
            re.compile(r'/(?:usr|etc|var|tmp|home)/[^\s"<>|]+', re.IGNORECASE)  # Unix paths
        ]
        paths = []
        for s in strings:
            for pattern in path_patterns:
                paths.extend(pattern.findall(s))
        return list(set(paths))[:30]

    def _extract_crypto_constants(self, strings: List[str]) -> List[str]:
        """Extract cryptographic constants"""
        crypto_constants = [
            "expand 32-byte k",  # Salsa20/ChaCha20
            "expand 16-byte k",
            # Common crypto algorithm indicators
        ]
        found = []
        for s in strings:
            for const in crypto_constants:
                if const in s:
                    found.append(s)
        return list(set(found))[:10]

    def _extract_suspicious_strings(self, strings: List[str]) -> List[str]:
        """Extract suspicious strings"""
        suspicious_keywords = [
            'password', 'encrypt', 'decrypt', 'ransom', 'backdoor',
            'keylog', 'inject', 'payload', 'exploit', 'rootkit',
            'trojan', 'virus', 'worm', 'malware', 'cmd.exe',
            'powershell', 'administrator', 'privilege', 'elevation'
        ]

        suspicious = []
        for s in strings:
            s_lower = s.lower()
            if any(keyword in s_lower for keyword in suspicious_keywords):
                suspicious.append(s)

        return list(set(suspicious))[:50]
