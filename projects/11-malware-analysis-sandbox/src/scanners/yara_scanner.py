"""
YARA Scanner
Scans files using YARA rules for malware detection
"""

import os
from pathlib import Path
from typing import List, Optional, Dict, Any

try:
    import yara
    YARA_AVAILABLE = True
except ImportError:
    YARA_AVAILABLE = False

from ..models import YARAMatch


class YARAScanner:
    """
    YARA-based malware scanner
    Loads and applies YARA rules to detect malware patterns
    """

    def __init__(self, rules_path: Optional[str] = None):
        """
        Initialize YARA scanner

        Args:
            rules_path: Path to directory containing YARA rules or single rule file
        """
        self.rules_path = rules_path
        self.rules = None
        self.compiled_rules = {}

        if rules_path and YARA_AVAILABLE:
            self.load_rules(rules_path)

    def load_rules(self, rules_path: str):
        """
        Load YARA rules from file or directory

        Args:
            rules_path: Path to rules file or directory
        """
        if not YARA_AVAILABLE:
            raise ImportError("yara-python is not installed")

        path = Path(rules_path)

        if path.is_file():
            # Single rule file
            self.rules = yara.compile(filepath=str(path))
            self.compiled_rules[path.stem] = self.rules
        elif path.is_dir():
            # Directory of rule files
            rule_files = {}
            for rule_file in path.glob('*.yar'):
                rule_files[rule_file.stem] = str(rule_file)

            if rule_files:
                self.rules = yara.compile(filepaths=rule_files)
                self.compiled_rules = rule_files
        else:
            raise FileNotFoundError(f"Rules path not found: {rules_path}")

    def scan_file(self, filepath: str, timeout: int = 60) -> List[YARAMatch]:
        """
        Scan file with YARA rules

        Args:
            filepath: Path to file to scan
            timeout: Scan timeout in seconds

        Returns:
            List of YARA matches
        """
        if not YARA_AVAILABLE:
            return []

        if not self.rules:
            return []

        matches = []

        try:
            yara_matches = self.rules.match(
                filepath,
                timeout=timeout
            )

            for match in yara_matches:
                # Extract matched strings
                matched_strings = []
                for string_match in match.strings:
                    matched_strings.append({
                        'offset': string_match[0],
                        'identifier': string_match[1],
                        'data': string_match[2].decode('utf-8', errors='ignore')
                            if isinstance(string_match[2], bytes)
                            else str(string_match[2])
                    })

                matches.append(YARAMatch(
                    rule_name=match.rule,
                    namespace=match.namespace,
                    tags=list(match.tags),
                    strings=matched_strings,
                    meta=match.meta
                ))

        except yara.TimeoutError:
            print(f"YARA scan timeout for {filepath}")
        except Exception as e:
            print(f"YARA scan error: {e}")

        return matches

    def scan_data(self, data: bytes, timeout: int = 60) -> List[YARAMatch]:
        """
        Scan data buffer with YARA rules

        Args:
            data: Data to scan
            timeout: Scan timeout in seconds

        Returns:
            List of YARA matches
        """
        if not YARA_AVAILABLE or not self.rules:
            return []

        matches = []

        try:
            yara_matches = self.rules.match(
                data=data,
                timeout=timeout
            )

            for match in yara_matches:
                matched_strings = []
                for string_match in match.strings:
                    matched_strings.append({
                        'offset': string_match[0],
                        'identifier': string_match[1],
                        'data': string_match[2].decode('utf-8', errors='ignore')
                            if isinstance(string_match[2], bytes)
                            else str(string_match[2])
                    })

                matches.append(YARAMatch(
                    rule_name=match.rule,
                    namespace=match.namespace,
                    tags=list(match.tags),
                    strings=matched_strings,
                    meta=match.meta
                ))

        except yara.TimeoutError:
            print("YARA scan timeout")
        except Exception as e:
            print(f"YARA scan error: {e}")

        return matches

    def create_custom_rule(
        self,
        rule_name: str,
        strings: Dict[str, str],
        condition: str,
        meta: Optional[Dict[str, Any]] = None,
        tags: Optional[List[str]] = None
    ) -> str:
        """
        Create a custom YARA rule

        Args:
            rule_name: Name of the rule
            strings: Dictionary of string identifiers and patterns
            condition: YARA condition expression
            meta: Metadata dictionary
            tags: List of tags

        Returns:
            YARA rule as string
        """
        rule_lines = []

        # Rule declaration
        if tags:
            rule_lines.append(f"rule {rule_name} : {' '.join(tags)}")
        else:
            rule_lines.append(f"rule {rule_name}")

        rule_lines.append("{")

        # Meta section
        if meta:
            rule_lines.append("    meta:")
            for key, value in meta.items():
                if isinstance(value, str):
                    rule_lines.append(f'        {key} = "{value}"')
                else:
                    rule_lines.append(f'        {key} = {value}')

        # Strings section
        if strings:
            rule_lines.append("    strings:")
            for identifier, pattern in strings.items():
                rule_lines.append(f'        ${identifier} = "{pattern}"')

        # Condition section
        rule_lines.append("    condition:")
        rule_lines.append(f"        {condition}")

        rule_lines.append("}")

        return "\n".join(rule_lines)


def get_default_rules() -> Dict[str, str]:
    """
    Get a set of default YARA rules for common malware patterns

    Returns:
        Dictionary of rule names to rule content
    """
    rules = {}

    # Generic ransomware indicators
    rules['ransomware_indicators'] = '''
rule ransomware_indicators
{
    meta:
        description = "Detects common ransomware indicators"
        author = "Malware Analysis Sandbox"
        date = "2025-01-18"

    strings:
        $ransom1 = "your files have been encrypted" nocase
        $ransom2 = "bitcoin" nocase
        $ransom3 = "decrypt" nocase
        $ransom4 = "ransom" nocase
        $ext1 = ".locked"
        $ext2 = ".encrypted"
        $ext3 = ".crypt"

    condition:
        2 of ($ransom*) or 2 of ($ext*)
}
'''

    # Generic backdoor indicators
    rules['backdoor_indicators'] = '''
rule backdoor_indicators
{
    meta:
        description = "Detects common backdoor indicators"
        author = "Malware Analysis Sandbox"
        date = "2025-01-18"

    strings:
        $cmd1 = "cmd.exe" nocase
        $cmd2 = "powershell" nocase
        $cmd3 = "CreateRemoteThread"
        $cmd4 = "WriteProcessMemory"
        $net1 = "socket"
        $net2 = "connect"

    condition:
        2 of ($cmd*) and 1 of ($net*)
}
'''

    # Keylogger indicators
    rules['keylogger_indicators'] = '''
rule keylogger_indicators
{
    meta:
        description = "Detects keylogger indicators"
        author = "Malware Analysis Sandbox"
        date = "2025-01-18"

    strings:
        $key1 = "GetAsyncKeyState"
        $key2 = "SetWindowsHookEx"
        $key3 = "keylog" nocase
        $key4 = "WH_KEYBOARD"

    condition:
        any of them
}
'''

    # Packed executable indicators
    rules['packed_executable'] = '''
rule packed_executable
{
    meta:
        description = "Detects packed executables"
        author = "Malware Analysis Sandbox"
        date = "2025-01-18"

    strings:
        $upx = "UPX!"
        $aspack = "ASPack"
        $pecompact = "PECompact"
        $mpress = ".MPRESS"

    condition:
        any of them
}
'''

    # Suspicious API usage
    rules['suspicious_apis'] = '''
rule suspicious_apis
{
    meta:
        description = "Detects suspicious Windows API usage"
        author = "Malware Analysis Sandbox"
        date = "2025-01-18"

    strings:
        $api1 = "VirtualAllocEx"
        $api2 = "CreateRemoteThread"
        $api3 = "WriteProcessMemory"
        $api4 = "LoadLibrary"
        $api5 = "GetProcAddress"

    condition:
        3 of them
}
'''

    return rules


def save_default_rules(output_dir: str):
    """
    Save default YARA rules to directory

    Args:
        output_dir: Directory to save rules
    """
    rules = get_default_rules()
    output_path = Path(output_dir)
    output_path.mkdir(parents=True, exist_ok=True)

    for rule_name, rule_content in rules.items():
        rule_file = output_path / f"{rule_name}.yar"
        with open(rule_file, 'w') as f:
            f.write(rule_content)

    print(f"Saved {len(rules)} default rules to {output_dir}")
