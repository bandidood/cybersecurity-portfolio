"""
Sample Manager
Manages malware samples securely
"""

import os
import shutil
import json
from pathlib import Path
from typing import List, Optional, Dict
from datetime import datetime

from ..models import MalwareSample, AnalysisStatus


class SampleManager:
    """
    Manages malware sample storage and metadata
    """

    def __init__(self, storage_path: str = "samples"):
        """
        Initialize sample manager

        Args:
            storage_path: Directory to store samples
        """
        self.storage_path = Path(storage_path)
        self.storage_path.mkdir(parents=True, exist_ok=True)

        # Create subdirectories
        self.pending_dir = self.storage_path / "pending"
        self.analyzed_dir = self.storage_path / "analyzed"
        self.quarantine_dir = self.storage_path / "quarantine"
        self.metadata_dir = self.storage_path / "metadata"

        for directory in [self.pending_dir, self.analyzed_dir,
                          self.quarantine_dir, self.metadata_dir]:
            directory.mkdir(parents=True, exist_ok=True)

    def import_sample(
        self,
        filepath: str,
        move: bool = False,
        tags: Optional[List[str]] = None,
        notes: str = ""
    ) -> MalwareSample:
        """
        Import a sample into the sandbox

        Args:
            filepath: Path to sample file
            move: If True, move file instead of copy
            tags: Optional tags for the sample
            notes: Optional notes about the sample

        Returns:
            MalwareSample object
        """
        # Create sample object
        sample = MalwareSample.from_file(filepath)

        if tags:
            sample.tags = tags
        if notes:
            sample.notes = notes

        # Determine storage location
        sample_filename = f"{sample.sample_id}_{sample.file_info.filename}"
        dest_path = self.pending_dir / sample_filename

        # Copy or move file
        if move:
            shutil.move(filepath, dest_path)
        else:
            shutil.copy2(filepath, dest_path)

        # Update filepath in sample
        sample.file_info.filepath = str(dest_path)

        # Save metadata
        self._save_metadata(sample)

        return sample

    def get_sample(self, sample_id: str) -> Optional[MalwareSample]:
        """
        Retrieve sample by ID

        Args:
            sample_id: Sample ID

        Returns:
            MalwareSample object or None
        """
        metadata_file = self.metadata_dir / f"{sample_id}.json"

        if not metadata_file.exists():
            return None

        with open(metadata_file, 'r') as f:
            data = json.load(f)

        # Reconstruct sample object
        # (simplified - full reconstruction would need more complex deserialization)
        sample = MalwareSample.from_file(data['file_info']['filepath'])
        sample.sample_id = data['sample_id']
        sample.status = AnalysisStatus(data['status'])
        sample.tags = data.get('tags', [])
        sample.notes = data.get('notes', '')

        return sample

    def list_samples(
        self,
        status: Optional[AnalysisStatus] = None,
        tags: Optional[List[str]] = None,
        limit: int = 100
    ) -> List[Dict]:
        """
        List samples with optional filtering

        Args:
            status: Filter by analysis status
            tags: Filter by tags (match any)
            limit: Maximum number of results

        Returns:
            List of sample metadata dictionaries
        """
        samples = []

        for metadata_file in self.metadata_dir.glob("*.json"):
            with open(metadata_file, 'r') as f:
                data = json.load(f)

            # Apply filters
            if status and data['status'] != status.value:
                continue

            if tags and not any(tag in data.get('tags', []) for tag in tags):
                continue

            samples.append(data)

            if len(samples) >= limit:
                break

        # Sort by submission date (newest first)
        samples.sort(
            key=lambda x: x.get('submitted_at', ''),
            reverse=True
        )

        return samples

    def update_sample(self, sample: MalwareSample):
        """
        Update sample metadata

        Args:
            sample: MalwareSample object with updated data
        """
        # Move file if status changed
        current_path = Path(sample.file_info.filepath)

        if sample.status == AnalysisStatus.COMPLETED:
            new_dir = self.analyzed_dir
        elif sample.status in [AnalysisStatus.PENDING, AnalysisStatus.RUNNING]:
            new_dir = self.pending_dir
        else:
            new_dir = self.quarantine_dir

        new_path = new_dir / current_path.name

        if current_path != new_path and current_path.exists():
            shutil.move(str(current_path), str(new_path))
            sample.file_info.filepath = str(new_path)

        # Save updated metadata
        self._save_metadata(sample)

    def delete_sample(self, sample_id: str, delete_file: bool = True):
        """
        Delete sample and metadata

        Args:
            sample_id: Sample ID
            delete_file: If True, also delete the sample file
        """
        # Delete metadata
        metadata_file = self.metadata_dir / f"{sample_id}.json"
        if metadata_file.exists():
            # Get file path before deleting metadata
            if delete_file:
                with open(metadata_file, 'r') as f:
                    data = json.load(f)
                    filepath = data['file_info']['filepath']
                    if os.path.exists(filepath):
                        os.remove(filepath)

            metadata_file.unlink()

    def search_samples(
        self,
        query: str,
        search_fields: Optional[List[str]] = None,
        limit: int = 50
    ) -> List[Dict]:
        """
        Search samples by text query

        Args:
            query: Search query
            search_fields: Fields to search (filename, notes, tags, family)
            limit: Maximum results

        Returns:
            List of matching sample metadata
        """
        if search_fields is None:
            search_fields = ['filename', 'notes', 'tags', 'family']

        query_lower = query.lower()
        results = []

        for metadata_file in self.metadata_dir.glob("*.json"):
            with open(metadata_file, 'r') as f:
                data = json.load(f)

            # Check each search field
            match = False

            if 'filename' in search_fields:
                if query_lower in data['file_info']['filename'].lower():
                    match = True

            if 'notes' in search_fields:
                if query_lower in data.get('notes', '').lower():
                    match = True

            if 'tags' in search_fields:
                if any(query_lower in tag.lower() for tag in data.get('tags', [])):
                    match = True

            if 'family' in search_fields:
                family = data.get('malware_family', '')
                if family and query_lower in family.lower():
                    match = True

            if match:
                results.append(data)

            if len(results) >= limit:
                break

        return results

    def get_statistics(self) -> Dict:
        """
        Get storage statistics

        Returns:
            Dictionary with statistics
        """
        stats = {
            'total_samples': 0,
            'by_status': {},
            'total_size_bytes': 0,
            'oldest_sample': None,
            'newest_sample': None
        }

        timestamps = []

        for metadata_file in self.metadata_dir.glob("*.json"):
            with open(metadata_file, 'r') as f:
                data = json.load(f)

            stats['total_samples'] += 1

            # Count by status
            status = data['status']
            stats['by_status'][status] = stats['by_status'].get(status, 0) + 1

            # Sum file sizes
            stats['total_size_bytes'] += data['file_info']['size']

            # Track timestamps
            submitted = data.get('submitted_at')
            if submitted:
                timestamps.append(submitted)

        if timestamps:
            timestamps.sort()
            stats['oldest_sample'] = timestamps[0]
            stats['newest_sample'] = timestamps[-1]

        return stats

    def _save_metadata(self, sample: MalwareSample):
        """Save sample metadata to JSON file"""
        metadata_file = self.metadata_dir / f"{sample.sample_id}.json"

        with open(metadata_file, 'w') as f:
            f.write(sample.to_json())

    def export_sample(self, sample_id: str, output_path: str):
        """
        Export sample file to specified path

        Args:
            sample_id: Sample ID
            output_path: Destination path
        """
        sample = self.get_sample(sample_id)
        if not sample:
            raise FileNotFoundError(f"Sample not found: {sample_id}")

        shutil.copy2(sample.file_info.filepath, output_path)

    def quarantine_sample(self, sample_id: str):
        """
        Move sample to quarantine

        Args:
            sample_id: Sample ID
        """
        sample = self.get_sample(sample_id)
        if not sample:
            raise FileNotFoundError(f"Sample not found: {sample_id}")

        sample.status = AnalysisStatus.ERROR
        sample.tags.append('quarantined')
        self.update_sample(sample)
