"""
Report Generator
Generates comprehensive analysis reports
"""

from datetime import datetime
from typing import Optional
from pathlib import Path

from ..models import MalwareSample, StaticAnalysisResult


class ReportGenerator:
    """
    Generates malware analysis reports in various formats
    """

    @staticmethod
    def generate_text_report(sample: MalwareSample) -> str:
        """
        Generate plain text report

        Args:
            sample: MalwareSample with analysis results

        Returns:
            Formatted text report
        """
        lines = []
        lines.append("="*80)
        lines.append(" MALWARE ANALYSIS REPORT".center(80))
        lines.append("="*80)
        lines.append("")

        # Basic Information
        lines.append("BASIC INFORMATION")
        lines.append("-"*80)
        lines.append(f"Sample ID:        {sample.sample_id}")
        lines.append(f"Filename:         {sample.file_info.filename}")
        lines.append(f"File Size:        {sample.file_info.size:,} bytes")
        lines.append(f"Submitted:        {sample.submitted_at.strftime('%Y-%m-%d %H:%M:%S')}")
        lines.append(f"Analysis Status:  {sample.status.value.upper()}")
        lines.append("")

        # File Hashes
        lines.append("FILE HASHES")
        lines.append("-"*80)
        lines.append(f"MD5:              {sample.file_info.md5}")
        lines.append(f"SHA1:             {sample.file_info.sha1}")
        lines.append(f"SHA256:           {sample.file_info.sha256}")
        lines.append("")

        # File Type
        lines.append("FILE TYPE INFORMATION")
        lines.append("-"*80)
        lines.append(f"Type:             {sample.file_info.file_type}")
        lines.append(f"MIME Type:        {sample.file_info.mime_type}")
        lines.append(f"Magic:            {sample.file_info.magic}")
        lines.append("")

        # Threat Assessment
        lines.append("THREAT ASSESSMENT")
        lines.append("-"*80)
        lines.append(f"Threat Level:     {sample.threat_level.value.upper()}")
        lines.append(f"Overall Score:    {sample.overall_score:.1f}/100")
        if sample.malware_family:
            lines.append(f"Family:           {sample.malware_family}")
        if sample.tags:
            lines.append(f"Tags:             {', '.join(sample.tags)}")
        lines.append("")

        # Static Analysis Results
        if sample.static_analysis:
            sa = sample.static_analysis

            lines.append("STATIC ANALYSIS RESULTS")
            lines.append("-"*80)
            lines.append(f"Sample Type:      {sa.sample_type.value}")
            lines.append(f"Threat Score:     {sa.threat_score:.1f}/100")
            lines.append(f"Analysis Time:    {sa.analysis_time:.2f}s")
            lines.append("")

            # PE Information
            if sa.pe_info:
                pe = sa.pe_info
                lines.append("PE EXECUTABLE INFORMATION")
                lines.append("-"*80)
                lines.append(f"Architecture:     {pe.architecture}")
                lines.append(f"Subsystem:        {pe.subsystem}")
                if pe.compilation_timestamp:
                    lines.append(f"Compiled:         {pe.compilation_timestamp.strftime('%Y-%m-%d %H:%M:%S')}")
                lines.append(f"Entry Point:      {hex(pe.entry_point)}")
                lines.append(f"Image Base:       {hex(pe.image_base)}")
                lines.append(f"Entropy:          {pe.entropy:.2f}")
                lines.append(f"Packed:           {'Yes' if pe.is_packed else 'No'}")
                if pe.packer:
                    lines.append(f"Packer:           {pe.packer}")
                lines.append("")

                # Sections
                if pe.sections:
                    lines.append(f"SECTIONS ({len(pe.sections)})")
                    lines.append("-"*80)
                    lines.append(f"{'Name':<12} {'VA':<12} {'VSize':<12} {'RSize':<12} {'Entropy':<10}")
                    lines.append("-"*80)
                    for section in pe.sections:
                        lines.append(
                            f"{section['name']:<12} "
                            f"{section['virtual_address']:<12} "
                            f"{section['virtual_size']:<12} "
                            f"{section['raw_size']:<12} "
                            f"{section['entropy']:<10.2f}"
                        )
                    lines.append("")

                # Imports
                if pe.imports:
                    lines.append(f"IMPORTED LIBRARIES ({len(pe.imports)})")
                    lines.append("-"*80)
                    for import_dict in pe.imports[:10]:  # Show first 10
                        for dll, functions in import_dict.items():
                            lines.append(f"{dll} ({len(functions)} functions)")
                            for func in functions[:5]:  # Show first 5 functions
                                lines.append(f"  - {func}")
                            if len(functions) > 5:
                                lines.append(f"  ... and {len(functions) - 5} more")
                    if len(pe.imports) > 10:
                        lines.append(f"... and {len(pe.imports) - 10} more DLLs")
                    lines.append("")

                # Exports
                if pe.exports:
                    lines.append(f"EXPORTED FUNCTIONS ({len(pe.exports)})")
                    lines.append("-"*80)
                    for export in pe.exports[:20]:
                        lines.append(f"  - {export}")
                    if len(pe.exports) > 20:
                        lines.append(f"  ... and {len(pe.exports) - 20} more")
                    lines.append("")

            # String Analysis
            if sa.string_analysis:
                strings = sa.string_analysis

                if strings.urls:
                    lines.append(f"URLS FOUND ({len(strings.urls)})")
                    lines.append("-"*80)
                    for url in strings.urls:
                        lines.append(f"  {url}")
                    lines.append("")

                if strings.ips:
                    lines.append(f"IP ADDRESSES FOUND ({len(strings.ips)})")
                    lines.append("-"*80)
                    for ip in strings.ips:
                        lines.append(f"  {ip}")
                    lines.append("")

                if strings.emails:
                    lines.append(f"EMAIL ADDRESSES FOUND ({len(strings.emails)})")
                    lines.append("-"*80)
                    for email in strings.emails:
                        lines.append(f"  {email}")
                    lines.append("")

                if strings.registry_keys:
                    lines.append(f"REGISTRY KEYS ({len(strings.registry_keys)})")
                    lines.append("-"*80)
                    for key in strings.registry_keys[:20]:
                        lines.append(f"  {key}")
                    if len(strings.registry_keys) > 20:
                        lines.append(f"  ... and {len(strings.registry_keys) - 20} more")
                    lines.append("")

                if strings.file_paths:
                    lines.append(f"FILE PATHS ({len(strings.file_paths)})")
                    lines.append("-"*80)
                    for path in strings.file_paths[:20]:
                        lines.append(f"  {path}")
                    if len(strings.file_paths) > 20:
                        lines.append(f"  ... and {len(strings.file_paths) - 20} more")
                    lines.append("")

                if strings.suspicious_strings:
                    lines.append(f"SUSPICIOUS STRINGS ({len(strings.suspicious_strings)})")
                    lines.append("-"*80)
                    for s in strings.suspicious_strings[:30]:
                        lines.append(f"  {s}")
                    if len(strings.suspicious_strings) > 30:
                        lines.append(f"  ... and {len(strings.suspicious_strings) - 30} more")
                    lines.append("")

            # YARA Matches
            if sa.yara_matches:
                lines.append(f"YARA RULE MATCHES ({len(sa.yara_matches)})")
                lines.append("-"*80)
                for match in sa.yara_matches:
                    lines.append(f"Rule: {match.rule_name}")
                    if match.tags:
                        lines.append(f"  Tags: {', '.join(match.tags)}")
                    if match.meta:
                        lines.append(f"  Meta:")
                        for key, value in match.meta.items():
                            lines.append(f"    {key}: {value}")
                    if match.strings:
                        lines.append(f"  Matched Strings:")
                        for s in match.strings[:5]:
                            lines.append(f"    {s['identifier']} at offset {s['offset']}: {s['data'][:50]}")
                    lines.append("")

            # Indicators of Compromise
            if sa.indicators:
                lines.append(f"INDICATORS OF COMPROMISE ({len(sa.indicators)})")
                lines.append("-"*80)
                for indicator in sa.indicators:
                    lines.append(f"  {indicator}")
                lines.append("")

        # Dynamic Behavior
        if sample.dynamic_behavior:
            db = sample.dynamic_behavior

            lines.append("DYNAMIC ANALYSIS RESULTS")
            lines.append("-"*80)

            if db.processes_created:
                lines.append(f"Processes Created ({len(db.processes_created)}):")
                for proc in db.processes_created:
                    lines.append(f"  - {proc}")

            if db.files_created:
                lines.append(f"Files Created ({len(db.files_created)}):")
                for f in db.files_created[:20]:
                    lines.append(f"  - {f}")

            if db.network_connections:
                lines.append(f"Network Connections ({len(db.network_connections)}):")
                for conn in db.network_connections:
                    lines.append(f"  - {conn}")

            if db.registry_keys_set:
                lines.append(f"Registry Keys Modified ({len(db.registry_keys_set)}):")
                for key in db.registry_keys_set[:20]:
                    lines.append(f"  - {key}")

            lines.append("")

        # Notes
        if sample.notes:
            lines.append("NOTES")
            lines.append("-"*80)
            lines.append(sample.notes)
            lines.append("")

        # Footer
        lines.append("="*80)
        lines.append(f"Report Generated: {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}")
        lines.append("="*80)

        return "\n".join(lines)

    @staticmethod
    def generate_markdown_report(sample: MalwareSample) -> str:
        """
        Generate Markdown report

        Args:
            sample: MalwareSample with analysis results

        Returns:
            Formatted Markdown report
        """
        lines = []

        # Header
        lines.append("# Malware Analysis Report")
        lines.append("")
        lines.append(f"**Generated:** {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}")
        lines.append("")

        # Executive Summary
        lines.append("## Executive Summary")
        lines.append("")
        lines.append(f"- **Sample ID:** `{sample.sample_id}`")
        lines.append(f"- **Filename:** `{sample.file_info.filename}`")
        lines.append(f"- **File Size:** {sample.file_info.size:,} bytes")
        lines.append(f"- **Threat Level:** **{sample.threat_level.value.upper()}**")
        lines.append(f"- **Threat Score:** {sample.overall_score:.1f}/100")
        if sample.malware_family:
            lines.append(f"- **Family:** {sample.malware_family}")
        lines.append("")

        # File Hashes
        lines.append("## File Hashes")
        lines.append("")
        lines.append(f"- **MD5:** `{sample.file_info.md5}`")
        lines.append(f"- **SHA1:** `{sample.file_info.sha1}`")
        lines.append(f"- **SHA256:** `{sample.file_info.sha256}`")
        lines.append("")

        # Static Analysis
        if sample.static_analysis:
            sa = sample.static_analysis

            lines.append("## Static Analysis")
            lines.append("")

            if sa.pe_info:
                pe = sa.pe_info
                lines.append("### PE Information")
                lines.append("")
                lines.append(f"- **Architecture:** {pe.architecture}")
                lines.append(f"- **Subsystem:** {pe.subsystem}")
                lines.append(f"- **Entropy:** {pe.entropy:.2f}")
                lines.append(f"- **Packed:** {'Yes' if pe.is_packed else 'No'}")
                if pe.packer:
                    lines.append(f"- **Packer:** {pe.packer}")
                lines.append("")

            if sa.string_analysis:
                strings = sa.string_analysis

                if strings.urls:
                    lines.append("### URLs")
                    lines.append("")
                    for url in strings.urls:
                        lines.append(f"- `{url}`")
                    lines.append("")

                if strings.ips:
                    lines.append("### IP Addresses")
                    lines.append("")
                    for ip in strings.ips:
                        lines.append(f"- `{ip}`")
                    lines.append("")

            if sa.yara_matches:
                lines.append("### YARA Matches")
                lines.append("")
                for match in sa.yara_matches:
                    lines.append(f"#### {match.rule_name}")
                    lines.append("")
                    if match.meta:
                        for key, value in match.meta.items():
                            lines.append(f"- **{key}:** {value}")
                    lines.append("")

        lines.append("---")
        lines.append("")
        lines.append("*Report generated by Malware Analysis Sandbox*")

        return "\n".join(lines)

    @staticmethod
    def save_report(sample: MalwareSample, output_path: str, format: str = "text"):
        """
        Save report to file

        Args:
            sample: MalwareSample with analysis results
            output_path: Path to save report
            format: Report format ('text', 'markdown', or 'json')
        """
        if format == "text":
            content = ReportGenerator.generate_text_report(sample)
        elif format == "markdown":
            content = ReportGenerator.generate_markdown_report(sample)
        elif format == "json":
            content = sample.to_json()
        else:
            raise ValueError(f"Unknown format: {format}")

        with open(output_path, 'w') as f:
            f.write(content)

        print(f"Report saved to: {output_path}")
